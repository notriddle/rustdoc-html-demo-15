searchState.loadedDescShard("core", 3, "Unsigned reciprocal square root estimate\nFloating-point reciprocal square root step\nFloating-point reciprocal square root step\nSigned rounding shift right and accumulate\nSigned rounding shift right and accumulate\nSigned rounding shift right and accumulate\nSigned rounding shift right and accumulate\nUnsigned rounding shift right and accumulate\nUnsigned rounding shift right and accumulate\nUnsigned rounding shift right and accumulate\nUnsigned rounding shift right and accumulate\nSigned rounding shift right and accumulate\nSigned rounding shift right and accumulate\nSigned rounding shift right and accumulate\nSigned rounding shift right and accumulate\nUnsigned rounding shift right and accumulate\nUnsigned rounding shift right and accumulate\nUnsigned rounding shift right and accumulate\nUnsigned rounding shift right and accumulate\nRounding subtract returning high narrow\nRounding subtract returning high narrow\nRounding subtract returning high narrow\nRounding subtract returning high narrow\nRounding subtract returning high narrow\nRounding subtract returning high narrow\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nSHA1 hash update accelerator, choose.\nSHA1 fixed rotate.\nSHA1 hash update accelerator, majority.\nSHA1 hash update accelerator, parity.\nSHA1 schedule update accelerator, first part.\nSHA1 schedule update accelerator, second part.\nSHA256 hash update accelerator, upper part.\nSHA256 hash update accelerator.\nSHA256 schedule update accelerator, first part.\nSHA256 schedule update accelerator, second part.\nShift left\nShift left\nShift left\nShift left\nShift left\nShift left\nShift left\nShift left\nSigned Shift left\nSigned Shift left\nSigned Shift left\nSigned Shift left\nUnsigned Shift left\nUnsigned Shift left\nUnsigned Shift left\nUnsigned Shift left\nSigned shift left long\nSigned shift left long\nSigned shift left long\nSigned shift left long\nSigned shift left long\nSigned shift left long\nShift left\nShift left\nShift left\nShift left\nShift left\nShift left\nShift left\nShift left\nSigned Shift left\nSigned Shift left\nSigned Shift left\nSigned Shift left\nUnsigned Shift left\nUnsigned Shift left\nUnsigned Shift left\nUnsigned Shift left\nShift right\nShift right\nShift right\nShift right\nShift right\nShift right\nShift right\nShift right\nShift right narrow\nShift right narrow\nShift right narrow\nShift right narrow\nShift right narrow\nShift right narrow\nShift right\nShift right\nShift right\nShift right\nShift right\nShift right\nShift right\nShift right\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nSigned shift right and accumulate\nSigned shift right and accumulate\nSigned shift right and accumulate\nSigned shift right and accumulate\nUnsigned shift right and accumulate\nUnsigned shift right and accumulate\nUnsigned shift right and accumulate\nUnsigned shift right and accumulate\nSigned shift right and accumulate\nSigned shift right and accumulate\nSigned shift right and accumulate\nSigned shift right and accumulate\nUnsigned shift right and accumulate\nUnsigned shift right and accumulate\nUnsigned shift right and accumulate\nUnsigned shift right and accumulate\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore SIMD&amp;FP register (immediate offset)\nSubtract\nSubtract\nSubtract\nSubtract\nSubtract\nSubtract\nSubtract\nSubtract\nSubtract\nSubtract returning high narrow\nSubtract returning high narrow\nSubtract returning high narrow\nSubtract returning high narrow\nSubtract returning high narrow\nSubtract returning high narrow\nSubtract returning high narrow\nSubtract returning high narrow\nSubtract returning high narrow\nSubtract returning high narrow\nSubtract returning high narrow\nSubtract returning high narrow\nSigned Subtract Long\nSigned Subtract Long\nSigned Subtract Long\nUnsigned Subtract Long\nUnsigned Subtract Long\nUnsigned Subtract Long\nSubtract\nSubtract\nSubtract\nSubtract\nSubtract\nSubtract\nSubtract\nSubtract\nSubtract\nSigned Subtract Wide\nSigned Subtract Wide\nSigned Subtract Wide\nUnsigned Subtract Wide\nUnsigned Subtract Wide\nUnsigned Subtract Wide\nDot product index form with signed and unsigned integers\nDot product index form with signed and unsigned integers\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nSigned compare bitwise Test bits nonzero\nSigned compare bitwise Test bits nonzero\nSigned compare bitwise Test bits nonzero\nSigned compare bitwise Test bits nonzero\nSigned compare bitwise Test bits nonzero\nUnsigned compare bitwise Test bits nonzero\nUnsigned compare bitwise Test bits nonzero\nUnsigned compare bitwise Test bits nonzero\nSigned compare bitwise Test bits nonzero\nSigned compare bitwise Test bits nonzero\nSigned compare bitwise Test bits nonzero\nSigned compare bitwise Test bits nonzero\nSigned compare bitwise Test bits nonzero\nUnsigned compare bitwise Test bits nonzero\nUnsigned compare bitwise Test bits nonzero\nUnsigned compare bitwise Test bits nonzero\nDot product index form with unsigned and signed integers\nDot product vector form with unsigned and signed integers\nDot product index form with unsigned and signed integers\nDot product vector form with unsigned and signed integers\nUnsigned and signed 8-bit integer matrix …\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLOONGARCH-specific 256-bit wide vector of 16 packed <code>i16</code>.\nLOONGARCH-specific 128-bit wide vector of 16 packed <code>i8</code>.\nLOONGARCH-specific 256-bit wide vector of 16 packed <code>u16</code>.\nLOONGARCH-specific 128-bit wide vector of 16 packed <code>u8</code>.\nLOONGARCH-specific 128-bit wide vector of 2 packed <code>f64</code>.\nLOONGARCH-specific 128-bit wide vector of 2 packed <code>i64</code>.\nLOONGARCH-specific 128-bit wide vector of 2 packed <code>u64</code>.\nLOONGARCH-specific 256-bit wide vector of 32 packed <code>i8</code>.\nLOONGARCH-specific 256-bit wide vector of 32 packed <code>u8</code>.\nLOONGARCH-specific 128-bit wide vector of 4 packed <code>f32</code>.\nLOONGARCH-specific 256-bit wide vector of 4 packed <code>f64</code>.\nLOONGARCH-specific 128-bit wide vector of 4 packed <code>i32</code>.\nLOONGARCH-specific 256-bit wide vector of 4 packed <code>i64</code>.\nLOONGARCH-specific 128-bit wide vector of 4 packed <code>u32</code>.\nLOONGARCH-specific 256-bit wide vector of 4 packed <code>u64</code>.\nLOONGARCH-specific 128-bit wide vector of 8 packed <code>f32</code>.\nLOONGARCH-specific 128-bit wide vector of 8 packed <code>i16</code>.\nLOONGARCH-specific 256-bit wide vector of 8 packed <code>i32</code>.\nLOONGARCH-specific 128-bit wide vector of 8 packed <code>u16</code>.\nLOONGARCH-specific 256-bit wide vector of 8 packed <code>u32</code>.\nGenerates the trap instruction <code>BREAK</code>\nGenerates the trap instruction <code>BREAK</code>\nSyscall to be used whenever the <em>assert expression produces </em>…\nx-th thread-block dimension.\ny-th thread-block dimension.\nz-th thread-block dimension.\nx-th thread-block index.\ny-th thread-block index.\nz-th thread-block index.\nx-th block-grid dimension.\ny-th block-grid dimension.\nz-th block-grid dimension.\nSynchronizes all threads in the block.\nx-th thread index.\ny-th thread index.\nz-th thread index.\nPTX-specific 32-bit wide floating point (f16 x 2) vector …\nAdd two values, round to nearest even\nFused multiply-add, round to nearest even\nFind the maximum of two values\nFind the maximum of two values, NaNs pass through.\nFind the minimum of two values\nFind the minimum of two values, NaNs pass through.\nMultiply two values, round to nearest even\nArithmetic negate\nSubtract two values, round to nearest even\nFree previously dynamically allocated memory.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nAllocate memory dynamically from a fixed-size heap in …\nGenerates the trap instruction <code>TRAP</code>\nPrint formatted output from a kernel to a host-side output …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGenerates the trap instruction <code>TRAP</code>\nVector abs.\nVector abss.\nVector add.\nVector addc.\nVector Add Extended\nVector adds.\nVector All Elements Equal\nVector All Elements Greater or Equal\nVector All Elements Greater Than\nVector All In\nVector All Elements Less Than or Equal\nVector All Elements Less Than\nAll Elements Not a Number\nVector All Elements Not Equal\nAll Elements Not Greater Than or Equal\nAll Elements Not Greater Than\nAll Elements Not Less Than or Equal\nAll Elements Not Less Than\nAll Elements Numeric\nVector and.\nVector andc.\nVector All Elements Equal\nVector Any Element Greater or Equal\nVector Any Element Greater Than\nVector Any Element Less Than or Equal\nVector Any Element Less Than\nAny Elements Not a Number\nVector Any Elements Not Equal\nAny Elements Not Greater Than or Equal\nAny Elements Not Greater Than\nAny Elements Not Less Than or Equal\nAny Elements Not Less Than\nAny Elements Numeric\nAny Element Out of Bounds\nVector avg.\nVector ceil.\nVector cmpb.\nVector cmpeq.\nVector cmpge.\nVector cmpgt.\nVector cmple.\nVector cmplt.\nVector Compare Not Equal\nVector Count Leading Zeros\nVector Convert to Floating-Point\nVector Convert to Signed Integer\nVector Convert to Unsigned Integer\nVector expte.\nVector Extract\nVector floor.\nVector Insert\nVector Load Indexed.\nVector Load Element Indexed.\nVector Load Indexed Least Recently Used.\nVector Base-2 Logarithm Estimate\nVector Multiply Add\nVector Multiply Add Saturated\nVector max.\nVector Merge Even\nVector Merge High\nVector Merge Low\nVector Merge Odd\nMove From Vector Status and Control Register.\nVector min.\nVector Multiply Low and Add Unsigned Half Word\nVector Multiply Round and Add Saturated\nVector Multiply Sum\nVector Multiply Sum Saturated\nVector Multiply\nVector Multiply Even\nVector Multiply Odd\nVector NAND\nVector Negative Multiply Subtract\nVector nor.\nVector or.\nVector OR with Complement\nVector Pack\nVector Pack Saturated\nVector Pack Saturated Unsigned\nVector permute.\nVector Rotate Left\nVector Round\nVector Select\nVector Shift Left\nVector Shift Left Double\nVector Shift Left Double by Words\nVector Shift Left Long\nVector Shift Left by Octets\nVector Shift Left Variable\nVector Splat\nVector Splat to Signed Halfword\nVector Splat to Signed Word\nVector Splat to Signed Byte\nVector Splat to Unsigned Halfword\nVector Splat to Unsigned Word\nVector Splat to Unsigned Byte\nVector splats.\nVector Shift Right\nVector Shift Right Algebraic\nVector Shift Right Long\nVector Shift Right by Octets\nVector Shift Right Variable\nVector Store Indexed\nVector Store Element Indexed\nVector Store Indexed Least Recently Used\nVector sub.\nVector Subtract Carryout\nVector subs.\nVector Sum Across Partial (1/2) Saturated\nVector Sum Across Partial (1/4) Saturated\nVector Unpack High\nVector Unpack Low\nVSX Unaligned Load\nVector xor.\nVSX Unaligned Store\nVector permute.\nPowerPC-specific 128-bit wide vector mask of sixteen …\nPowerPC-specific 128-bit wide vector mask of four packed …\nPowerPC-specific 128-bit wide vector mask of two <code>i64</code>\nPowerPC-specific 128-bit wide vector mask of eight packed …\nPowerPC-specific 128-bit wide vector of two packed <code>f64</code>\nPowerPC-specific 128-bit wide vector of four packed <code>f32</code>\nPowerPC-specific 128-bit wide vector of sixteen packed <code>i8</code>\nPowerPC-specific 128-bit wide vector of four packed <code>i32</code>\nPowerPC-specific 128-bit wide vector of two packed <code>i64</code>\nPowerPC-specific 128-bit wide vector of eight packed <code>i16</code>\nPowerPC-specific 128-bit wide vector of sixteen packed <code>u8</code>\nPowerPC-specific 128-bit wide vector of four packed <code>u32</code>\nPowerPC-specific 128-bit wide vector of two packed <code>u64</code>\nPowerPC-specific 128-bit wide vector of eight packed <code>u16</code>\nGenerates the trap instruction <code>TRAP</code>\nVector abs.\nVector abss.\nVector add.\nVector addc.\nVector Add Extended\nVector adds.\nVector All Elements Equal\nVector All Elements Greater or Equal\nVector All Elements Greater Than\nVector All In\nVector All Elements Less Than or Equal\nVector All Elements Less Than\nAll Elements Not a Number\nVector All Elements Not Equal\nAll Elements Not Greater Than or Equal\nAll Elements Not Greater Than\nAll Elements Not Less Than or Equal\nAll Elements Not Less Than\nAll Elements Numeric\nVector and.\nVector andc.\nVector All Elements Equal\nVector Any Element Greater or Equal\nVector Any Element Greater Than\nVector Any Element Less Than or Equal\nVector Any Element Less Than\nAny Elements Not a Number\nVector Any Elements Not Equal\nAny Elements Not Greater Than or Equal\nAny Elements Not Greater Than\nAny Elements Not Less Than or Equal\nAny Elements Not Less Than\nAny Elements Numeric\nAny Element Out of Bounds\nVector avg.\nVector ceil.\nVector cmpb.\nVector cmpeq.\nVector cmpge.\nVector cmpgt.\nVector cmple.\nVector cmplt.\nVector Compare Not Equal\nVector Count Leading Zeros\nVector Convert to Floating-Point\nVector Convert to Signed Integer\nVector Convert to Unsigned Integer\nVector expte.\nVector Extract\nVector floor.\nVector Insert\nVector Load Indexed.\nVector Load Element Indexed.\nVector Load Indexed Least Recently Used.\nVector Base-2 Logarithm Estimate\nVector Multiply Add\nVector Multiply Add Saturated\nVector max.\nVector Merge Even\nVector Merge High\nVector Merge Low\nVector Merge Odd\nMove From Vector Status and Control Register.\nVector min.\nVector Multiply Low and Add Unsigned Half Word\nVector Multiply Round and Add Saturated\nVector Multiply Sum\nVector Multiply Sum Saturated\nVector Multiply\nVector Multiply Even\nVector Multiply Odd\nVector NAND\nVector Negative Multiply Subtract\nVector nor.\nVector or.\nVector OR with Complement\nVector Pack\nVector Pack Saturated\nVector Pack Saturated Unsigned\nVector permute.\nVector Rotate Left\nVector Round\nVector Select\nVector Shift Left\nVector Shift Left Double\nVector Shift Left Double by Words\nVector Shift Left Long\nVector Shift Left by Octets\nVector Shift Left Variable\nVector Splat\nVector Splat to Signed Halfword\nVector Splat to Signed Word\nVector Splat to Signed Byte\nVector Splat to Unsigned Halfword\nVector Splat to Unsigned Word\nVector Splat to Unsigned Byte\nVector splats.\nVector Shift Right\nVector Shift Right Algebraic\nVector Shift Right Long\nVector Shift Right by Octets\nVector Shift Right Variable\nVector Store Indexed\nVector Store Element Indexed\nVector Store Indexed Least Recently Used\nVector sub.\nVector Subtract Carryout\nVector subs.\nVector Sum Across Partial (1/2) Saturated\nVector Sum Across Partial (1/4) Saturated\nVector Unpack High\nVector Unpack Low\nVSX Unaligned Load\nVector Load with Length\nVector xor.\nVSX Unaligned Store\nVector Store with Length\nVector permute.\nPowerPC-specific 128-bit wide vector mask of sixteen …\nPowerPC-specific 128-bit wide vector mask of four packed …\nPowerPC-specific 128-bit wide vector mask of two <code>i64</code>\nPowerPC-specific 128-bit wide vector mask of eight packed …\nPowerPC-specific 128-bit wide vector of two packed <code>f64</code>\nPowerPC-specific 128-bit wide vector of four packed <code>f32</code>\nPowerPC-specific 128-bit wide vector of sixteen packed <code>i8</code>\nPowerPC-specific 128-bit wide vector of four packed <code>i32</code>\nPowerPC-specific 128-bit wide vector of two packed <code>i64</code>\nPowerPC-specific 128-bit wide vector of eight packed <code>i16</code>\nPowerPC-specific 128-bit wide vector of sixteen packed <code>u8</code>\nPowerPC-specific 128-bit wide vector of four packed <code>u32</code>\nPowerPC-specific 128-bit wide vector of two packed <code>u64</code>\nPowerPC-specific 128-bit wide vector of eight packed <code>u16</code>\nAdds packed 16-bit signed numbers, discarding overflow bits\nAdds packed 8-bit signed numbers, discarding overflow bits\nAES final round decryption instruction for RV32.\nAES middle round decryption instruction for RV32.\nAES final round encryption instruction for RV32.\nAES middle round encryption instruction for RV32 with.\nCarry-less multiply (low-part)\nCarry-less multiply (high-part)\nCarry-less multiply (reversed)\nCount the number of redundant sign bits of the packed …\nCount the number of redundant sign bits of the packed …\nCount the number of redundant sign bits of the packed …\nCount the number of leading zero bits of the packed 16-bit …\nCount the number of leading zero bits of the packed 32-bit …\nCount the number of leading zero bits of the packed 8-bit …\nCompare equality for packed 16-bit elements\nCompare equality for packed 8-bit elements\nCross adds and subtracts packed 16-bit signed numbers, …\nCross subtracts and adds packed 16-bit signed numbers, …\nGenerates the <code>FENCE.I</code> instruction\nReads the floating-point rounding mode register <code>frm</code>\nHypervisor memory management fence for guest physical …\nHypervisor memory management fence for all virtual …\nHypervisor memory management fence for guest physical …\nHypervisor memory management fence for given virtual …\nHypervisor memory management fence for given guest virtual …\nHypervisor memory management fence for all guest address …\nHypervisor memory management fence for given guest address …\nHypervisor memory management fence for given guest virtual …\nInvalidate hypervisor translation cache for guest physical …\nInvalidate hypervisor translation cache for all virtual …\nInvalidate hypervisor translation cache for guest physical …\nInvalidate hypervisor translation cache for given virtual …\nInvalidate hypervisor translation cache for given guest …\nInvalidate hypervisor translation cache for all guest …\nInvalidate hypervisor translation cache for given guest …\nInvalidate hypervisor translation cache for given guest …\nLoads virtual machine memory by signed byte integer\nLoads virtual machine memory by unsigned byte integer\nLoads virtual machine memory by signed half integer\nLoads virtual machine memory by unsigned half integer\nLoads virtual machine memory by signed word integer\nAccesses virtual machine instruction by unsigned half …\nAccesses virtual machine instruction by unsigned word …\nStores virtual machine memory by byte integer\nStores virtual machine memory by half integer\nStores virtual machine memory by word integer\nCompute the absolute value of packed 16-bit signed integers\nCompute the absolute value of packed 8-bit signed integers\nAdds packed 16-bit signed numbers, saturating at the …\nAdds packed 8-bit signed numbers, saturating at the …\nAdds signed lower 16-bit content of two registers with Q15 …\nCross adds and subtracts packed 16-bit signed numbers, …\nCross subtracts and adds packed 16-bit signed numbers, …\nLogical left shift packed 16-bit elements, saturating at …\nLogical left shift packed 8-bit elements, saturating at …\nLogical saturating left then arithmetic right shift packed …\nLogical saturating left then arithmetic right shift packed …\nLogical saturating left then arithmetic right shift packed …\nLogical saturating left then arithmetic right shift packed …\nStraight adds and subtracts packed 16-bit signed numbers, …\nStraight subtracts and adds packed 16-bit signed numbers, …\nSubtracts packed 16-bit signed numbers, saturating at the …\nSubtracts packed 8-bit signed numbers, saturating at the …\nSubtracts signed lower 16-bit content of two registers …\nGenerates the <code>NOP</code> instruction\nBitwise OR-Combine, byte granule\nGenerates the <code>PAUSE</code> instruction\nCalculate the sum of absolute difference of unsigned 8-bit …\nCalculate and accumulate the sum of absolute difference of …\nPack two 16-bit data from bottom and top half from 32-bit …\nPack two 16-bit data from top and bottom half from 32-bit …\nHalves the sum of packed 16-bit signed numbers, dropping …\nHalves the sum of packed 8-bit signed numbers, dropping …\nCross halves of adds and subtracts packed 16-bit signed …\nCross halves of subtracts and adds packed 16-bit signed …\nStraight halves of adds and subtracts packed 16-bit signed …\nStraight halves of subtracts and adds packed 16-bit signed …\nHalves the subtraction result of packed 16-bit signed …\nHalves the subtraction result of packed 8-bit signed …\nCompare whether 16-bit packed signed integers are less …\nCompare whether 8-bit packed signed integers are less than …\nCompare whether 16-bit packed signed integers are less …\nCompare whether 8-bit packed signed integers are less than …\nGenerates the <code>SFENCE.INVAL.IR</code> instruction\nSupervisor memory management fence for given virtual …\nSupervisor memory management fence for all address spaces …\nSupervisor memory management fence for given address space\nSupervisor memory management fence for given virtual …\nGenerates the <code>SFENCE.W.INVAL</code> instruction\nImplements the Sigma0 transformation function as used in …\nImplements the Sigma1 transformation function as used in …\nImplements the Sum0 transformation function as used in the …\nImplements the Sum1 transformation function as used in the …\nImplements the high half of the Sigma0 transformation, as …\nImplements the low half of the Sigma0 transformation, as …\nImplements the high half of the Sigma1 transformation, as …\nImplements the low half of the Sigma1 transformation, as …\nImplements the Sum0 transformation, as used in the …\nImplements the Sum1 transformation, as used in the …\nInvalidate supervisor translation cache for given virtual …\nInvalidate supervisor translation cache for all address …\nInvalidate supervisor translation cache for given address …\nInvalidate supervisor translation cache for given virtual …\nLogical left shift packed 16-bit elements, discarding …\nLogical left shift packed 8-bit elements, discarding …\nImplements the P0 transformation function as used in the …\nImplements the P1 transformation function as used in the …\nAccelerates the block encrypt/decrypt operation of the SM4 …\nAccelerates the Key Schedule operation of the SM4 block …\nMultiply signed 8-bit elements and add 16-bit elements on …\nMultiply signed to unsigned 8-bit and add 16-bit elements …\nGet maximum values from 16-bit packed signed integers\nGet maximum values from 8-bit packed signed integers\nGet minimum values from 16-bit packed signed integers\nGet minimum values from 8-bit packed signed integers\nArithmetic right shift packed 16-bit elements without …\nArithmetic right shift packed 16-bit elements with …\nArithmetic right shift packed 8-bit elements without …\nArithmetic right shift packed 8-bit elements with rounding …\nLogical right shift packed 16-bit elements without …\nLogical right shift packed 16-bit elements with rounding up\nLogical right shift packed 8-bit elements without rounding …\nLogical right shift packed 8-bit elements with rounding up\nStraight adds and subtracts packed 16-bit signed numbers, …\nStraight subtracts and adds packed 16-bit signed numbers, …\nSubtracts packed 16-bit signed numbers, discarding …\nSubtracts packed 8-bit signed numbers, discarding overflow …\nUnpack first and zeroth into two 16-bit signed halfwords …\nUnpack second and zeroth into two 16-bit signed halfwords …\nUnpack third and zeroth into two 16-bit signed halfwords …\nUnpack third and first into two 16-bit signed halfwords in …\nUnpack third and second into two 16-bit signed halfwords …\nSwap the 16-bit halfwords within each 32-bit word of a …\nSwap the 8-bit bytes within each 16-bit halfword of a …\nCompare whether 16-bit packed unsigned integers are less …\nCompare whether 8-bit packed unsigned integers are less …\nCompare whether 16-bit packed unsigned integers are less …\nCompare whether 8-bit packed unsigned integers are less …\nAdds packed 16-bit unsigned numbers, saturating at the …\nAdds packed 8-bit unsigned numbers, saturating at the …\nAdds signed lower 16-bit content of two registers with U16 …\nCross adds and subtracts packed 16-bit unsigned numbers, …\nCross subtracts and adds packed 16-bit unsigned numbers, …\nStraight adds and subtracts packed 16-bit unsigned …\nStraight subtracts and adds packed 16-bit unsigned …\nSubtracts packed 16-bit unsigned numbers, saturating at …\nSubtracts packed 8-bit unsigned numbers, saturating at the …\nSubtracts signed lower 16-bit content of two registers …\nMultiply unsigned 8-bit elements and add 16-bit elements …\nGet maximum values from 16-bit packed unsigned integers\nGet maximum values from 8-bit packed unsigned integers\nGet minimum values from 16-bit packed unsigned integers\nGet minimum values from 8-bit packed unsigned integers\nPlace odd and even bits of the source word into …\nHalves the sum of packed 16-bit unsigned numbers, dropping …\nHalves the sum of packed 8-bit unsigned numbers, dropping …\nCross halves of adds and subtracts packed 16-bit unsigned …\nCross halves of subtracts and adds packed 16-bit unsigned …\nStraight halves of adds and subtracts packed 16-bit …\nStraight halves of subtracts and adds packed 16-bit …\nHalves the subtraction result of packed 16-bit unsigned …\nHalves the subtraction result of packed 8-bit unsigned …\nGenerates the <code>WFI</code> instruction\nNibble-wise lookup of indicies into a vector.\nByte-wise lookup of indicies into a vector in registers.\nPlace upper/lower halves of the source register into …\nUnpack first and zeroth into two 16-bit unsigned halfwords …\nUnpack second and zeroth into two 16-bit unsigned …\nUnpack third and zeroth into two 16-bit unsigned halfwords …\nUnpack third and first into two 16-bit unsigned halfwords …\nUnpack third and second into two 16-bit unsigned halfwords …\nAdds packed 16-bit signed numbers, discarding overflow bits\nAdds packed 8-bit signed numbers, discarding overflow bits\nAES final round decryption instruction for RV64.\nAES middle round decryption instruction for RV64.\nAES final round encryption instruction for RV64.\nAES middle round encryption instruction for RV64.\nThis instruction accelerates the inverse MixColumns step …\nThis instruction implements part of the KeySchedule …\nThis instruction implements part of the KeySchedule …\nCarry-less multiply (low-part)\nCarry-less multiply (high-part)\nCarry-less multiply (reversed)\nCount the number of redundant sign bits of the packed …\nCount the number of redundant sign bits of the packed …\nCount the number of redundant sign bits of the packed …\nCount the number of leading zero bits of the packed 16-bit …\nCount the number of leading zero bits of the packed 32-bit …\nCount the number of leading zero bits of the packed 8-bit …\nCompare equality for packed 16-bit elements\nCompare equality for packed 8-bit elements\nCross adds and subtracts packed 16-bit signed numbers, …\nCross subtracts and adds packed 16-bit signed numbers, …\nGenerates the <code>FENCE.I</code> instruction\nReads the floating-point rounding mode register <code>frm</code>\nHypervisor memory management fence for guest physical …\nHypervisor memory management fence for all virtual …\nHypervisor memory management fence for guest physical …\nHypervisor memory management fence for given virtual …\nHypervisor memory management fence for given guest virtual …\nHypervisor memory management fence for all guest address …\nHypervisor memory management fence for given guest address …\nHypervisor memory management fence for given guest virtual …\nInvalidate hypervisor translation cache for guest physical …\nInvalidate hypervisor translation cache for all virtual …\nInvalidate hypervisor translation cache for guest physical …\nInvalidate hypervisor translation cache for given virtual …\nInvalidate hypervisor translation cache for given guest …\nInvalidate hypervisor translation cache for all guest …\nInvalidate hypervisor translation cache for given guest …\nInvalidate hypervisor translation cache for given guest …\nLoads virtual machine memory by signed byte integer\nLoads virtual machine memory by unsigned byte integer\nLoads virtual machine memory by double integer\nLoads virtual machine memory by signed half integer\nLoads virtual machine memory by unsigned half integer\nLoads virtual machine memory by signed word integer\nLoads virtual machine memory by unsigned word integer\nAccesses virtual machine instruction by unsigned half …\nAccesses virtual machine instruction by unsigned word …\nStores virtual machine memory by byte integer\nStores virtual machine memory by double integer\nStores virtual machine memory by half integer\nStores virtual machine memory by word integer\nCompute the absolute value of packed 16-bit signed integers\nCompute the absolute value of packed 8-bit signed integers\nAdds packed 16-bit signed numbers, saturating at the …\nAdds packed 8-bit signed numbers, saturating at the …\nAdds signed lower 16-bit content of two registers with Q15 …\nCross adds and subtracts packed 16-bit signed numbers, …\nCross subtracts and adds packed 16-bit signed numbers, …\nLogical left shift packed 16-bit elements, saturating at …\nLogical left shift packed 8-bit elements, saturating at …\nLogical saturating left then arithmetic right shift packed …\nLogical saturating left then arithmetic right shift packed …\nLogical saturating left then arithmetic right shift packed …\nLogical saturating left then arithmetic right shift packed …\nStraight adds and subtracts packed 16-bit signed numbers, …\nStraight subtracts and adds packed 16-bit signed numbers, …\nSubtracts packed 16-bit signed numbers, saturating at the …\nSubtracts packed 8-bit signed numbers, saturating at the …\nSubtracts signed lower 16-bit content of two registers …\nGenerates the <code>NOP</code> instruction\nBitwise OR-Combine, byte granule\nGenerates the <code>PAUSE</code> instruction\nCalculate the sum of absolute difference of unsigned 8-bit …\nCalculate and accumulate the sum of absolute difference of …\nPack two 16-bit data from bottom and top half from 32-bit …\nPack two 16-bit data from top and bottom half from 32-bit …\nHalves the sum of packed 16-bit signed numbers, dropping …\nHalves the sum of packed 8-bit signed numbers, dropping …\nCross halves of adds and subtracts packed 16-bit signed …\nCross halves of subtracts and adds packed 16-bit signed …\nStraight halves of adds and subtracts packed 16-bit signed …\nStraight halves of subtracts and adds packed 16-bit signed …\nHalves the subtraction result of packed 16-bit signed …\nHalves the subtraction result of packed 8-bit signed …\nCompare whether 16-bit packed signed integers are less …\nCompare whether 8-bit packed signed integers are less than …\nCompare whether 16-bit packed signed integers are less …\nCompare whether 8-bit packed signed integers are less than …\nGenerates the <code>SFENCE.INVAL.IR</code> instruction\nSupervisor memory management fence for given virtual …\nSupervisor memory management fence for all address spaces …\nSupervisor memory management fence for given address space\nSupervisor memory management fence for given virtual …\nGenerates the <code>SFENCE.W.INVAL</code> instruction\nImplements the Sigma0 transformation function as used in …\nImplements the Sigma1 transformation function as used in …\nImplements the Sum0 transformation function as used in the …\nImplements the Sum1 transformation function as used in the …\nImplements the Sigma0 transformation function as used in …\nImplements the Sigma1 transformation function as used in …\nImplements the Sum0 transformation function as used in the …\nImplements the Sum1 transformation function as used in the …\nInvalidate supervisor translation cache for given virtual …\nInvalidate supervisor translation cache for all address …\nInvalidate supervisor translation cache for given address …\nInvalidate supervisor translation cache for given virtual …\nLogical left shift packed 16-bit elements, discarding …\nLogical left shift packed 8-bit elements, discarding …\nImplements the P0 transformation function as used in the …\nImplements the P1 transformation function as used in the …\nAccelerates the block encrypt/decrypt operation of the SM4 …\nAccelerates the Key Schedule operation of the SM4 block …\nMultiply signed 8-bit elements and add 16-bit elements on …\nMultiply signed to unsigned 8-bit and add 16-bit elements …\nGet maximum values from 16-bit packed signed integers\nGet maximum values from 8-bit packed signed integers\nGet minimum values from 16-bit packed signed integers\nGet minimum values from 8-bit packed signed integers\nArithmetic right shift packed 16-bit elements without …\nArithmetic right shift packed 16-bit elements with …\nArithmetic right shift packed 8-bit elements without …\nArithmetic right shift packed 8-bit elements with rounding …\nLogical right shift packed 16-bit elements without …\nLogical right shift packed 16-bit elements with rounding up\nLogical right shift packed 8-bit elements without rounding …\nLogical right shift packed 8-bit elements with rounding up\nStraight adds and subtracts packed 16-bit signed numbers, …\nStraight subtracts and adds packed 16-bit signed numbers, …\nSubtracts packed 16-bit signed numbers, discarding …\nSubtracts packed 8-bit signed numbers, discarding overflow …\nUnpack first and zeroth into two 16-bit signed halfwords …\nUnpack second and zeroth into two 16-bit signed halfwords …\nUnpack third and zeroth into two 16-bit signed halfwords …\nUnpack third and first into two 16-bit signed halfwords in …\nUnpack third and second into two 16-bit signed halfwords …\nSwap the 16-bit halfwords within each 32-bit word of a …\nSwap the 8-bit bytes within each 16-bit halfword of a …\nCompare whether 16-bit packed unsigned integers are less …\nCompare whether 8-bit packed unsigned integers are less …\nCompare whether 16-bit packed unsigned integers are less …\nCompare whether 8-bit packed unsigned integers are less …\nAdds packed 16-bit unsigned numbers, saturating at the …\nAdds packed 8-bit unsigned numbers, saturating at the …\nAdds signed lower 16-bit content of two registers with U16 …\nCross adds and subtracts packed 16-bit unsigned numbers, …\nCross subtracts and adds packed 16-bit unsigned numbers, …\nStraight adds and subtracts packed 16-bit unsigned …\nStraight subtracts and adds packed 16-bit unsigned …\nSubtracts packed 16-bit unsigned numbers, saturating at …\nSubtracts packed 8-bit unsigned numbers, saturating at the …\nSubtracts signed lower 16-bit content of two registers …\nMultiply unsigned 8-bit elements and add 16-bit elements …\nGet maximum values from 16-bit packed unsigned integers\nGet maximum values from 8-bit packed unsigned integers\nGet minimum values from 16-bit packed unsigned integers\nGet minimum values from 8-bit packed unsigned integers\nHalves the sum of packed 16-bit unsigned numbers, dropping …\nHalves the sum of packed 8-bit unsigned numbers, dropping …\nCross halves of adds and subtracts packed 16-bit unsigned …\nCross halves of subtracts and adds packed 16-bit unsigned …\nStraight halves of adds and subtracts packed 16-bit …\nStraight halves of subtracts and adds packed 16-bit …\nHalves the subtraction result of packed 16-bit unsigned …\nHalves the subtraction result of packed 8-bit unsigned …\nGenerates the <code>WFI</code> instruction\nNibble-wise lookup of indicies into a vector.\nByte-wise lookup of indicies into a vector in registers.\nUnpack first and zeroth into two 16-bit unsigned halfwords …\nUnpack second and zeroth into two 16-bit unsigned …\nUnpack third and zeroth into two 16-bit unsigned halfwords …\nUnpack third and first into two 16-bit unsigned halfwords …\nUnpack third and second into two 16-bit unsigned halfwords …\nGenerates the <code>f32.ceil</code> instruction, returning the smallest …\nGenerates the <code>f32.floor</code> instruction, returning the largest …\nGenerates the <code>f32.nearest</code> instruction, roundinging to the …\nGenerates the <code>f32.sqrt</code> instruction, returning the square …\nGenerates the <code>f32.trunc</code> instruction, roundinging to the …\nMaterializes a SIMD value from the provided operands.\nCalculates the absolute value of each lane of a 128-bit …\nLane-wise addition of two 128-bit vectors interpreted as …\nLane-wise rounding to the nearest integral value not …\nConverts a 128-bit vector interpreted as four 32-bit …\nConverts a 128-bit vector interpreted as four 32-bit …\nConversion of the two double-precision floating point …\nLane-wise division of two 128-bit vectors interpreted as …\nCompares two 128-bit vectors as if they were two vectors …\nExtracts a lane from a 128-bit vector interpreted as 4 …\nLane-wise rounding to the nearest integral value not …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCalculates the lane-wise minimum of two 128-bit vectors …\nCalculates the lane-wise minimum of two 128-bit vectors …\nLane-wise multiplication of two 128-bit vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLane-wise rounding to the nearest integral value; if two …\nNegates each lane of a 128-bit vector interpreted as four …\nLane-wise maximum value, defined as <code>a &lt; b ? b : a</code>\nLane-wise minimum value, defined as <code>b &lt; a ? b : a</code>\nComputes <code>a * b + c</code> with either one rounding or two …\nA relaxed version of <code>f32x4_max</code> which is either <code>f32x4_max</code> or\nA relaxed version of <code>f32x4_min</code> which is either <code>f32x4_min</code> or\nComputes <code>-a * b + c</code> with either one rounding or two …\nReplaces a lane from a 128-bit vector interpreted as 4 …\nCreates a vector with identical lanes.\nCalculates the square root of each lane of a 128-bit …\nLane-wise subtraction of two 128-bit vectors interpreted …\nLane-wise rounding to the nearest integral value with the …\nGenerates the <code>f64.ceil</code> instruction, returning the smallest …\nGenerates the <code>f64.floor</code> instruction, returning the largest …\nGenerates the <code>f64.nearest</code> instruction, roundinging to the …\nGenerates the <code>f64.sqrt</code> instruction, returning the square …\nGenerates the <code>f64.trunc</code> instruction, roundinging to the …\nMaterializes a SIMD value from the provided operands.\nCalculates the absolute value of each lane of a 128-bit …\nLane-wise add of two 128-bit vectors interpreted as two …\nLane-wise rounding to the nearest integral value not …\nLane-wise conversion from integer to floating point.\nLane-wise conversion from integer to floating point.\nLane-wise divide of two 128-bit vectors interpreted as two …\nCompares two 128-bit vectors as if they were two vectors …\nExtracts a lane from a 128-bit vector interpreted as 2 …\nLane-wise rounding to the nearest integral value not …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCalculates the lane-wise maximum of two 128-bit vectors …\nCalculates the lane-wise minimum of two 128-bit vectors …\nLane-wise multiply of two 128-bit vectors interpreted as …\nCompares two 128-bit vectors as if they were two vectors …\nLane-wise rounding to the nearest integral value; if two …\nNegates each lane of a 128-bit vector interpreted as two …\nLane-wise maximum value, defined as <code>a &lt; b ? b : a</code>\nLane-wise minimum value, defined as <code>b &lt; a ? b : a</code>\nConversion of the two lower single-precision floating …\nComputes <code>a * b + c</code> with either one rounding or two …\nA relaxed version of <code>f64x2_max</code> which is either <code>f64x2_max</code> or\nA relaxed version of <code>f64x2_min</code> which is either <code>f64x2_min</code> or\nComputes <code>-a * b + c</code> with either one rounding or two …\nReplaces a lane from a 128-bit vector interpreted as 2 …\nCreates a vector with identical lanes.\nCalculates the square root of each lane of a 128-bit …\nLane-wise subtract of two 128-bit vectors interpreted as …\nLane-wise rounding to the nearest integral value with the …\nMaterializes a SIMD value from the provided operands.\nLane-wise wrapping absolute value.\nAdds two 128-bit vectors as if they were two packed eight …\nAdds two 128-bit vectors as if they were two packed eight …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nInteger extended pairwise addition producing extended …\nInteger extended pairwise addition producing extended …\nConverts high half of the smaller lane vector to a larger …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 8 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLoad eight 8-bit integers and sign extend each one to a …\nLoad eight 8-bit integers and zero extend each one to a …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise signed integers, and returns the …\nCompares lane-wise signed integers, and returns the …\nMultiplies two 128-bit vectors as if they were two packed …\nConverts two input vectors into a smaller lane vector by …\nCompares two 128-bit vectors as if they were two vectors …\nNegates a 128-bit vectors interpreted as eight 16-bit …\nLane-wise saturating rounding multiplication in Q15 format.\nA relaxed dot-product instruction.\nA relaxed version of <code>v128_bitselect</code> where this either …\nA relaxed version of <code>i16x8_relaxed_q15mulr</code> where if both …\nReplaces a lane from a 128-bit vector interpreted as 8 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nSubtracts two 128-bit vectors as if they were two packed …\nMaterializes a SIMD value from the provided operands.\nLane-wise wrapping absolute value.\nAdds two 128-bit vectors as if they were two packed four …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nLane-wise multiply signed 16-bit integers in the two input …\nCompares two 128-bit vectors as if they were two vectors …\nInteger extended pairwise addition producing extended …\nInteger extended pairwise addition producing extended …\nConverts high half of the smaller lane vector to a larger …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 4 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLoad four 16-bit integers and sign extend each one to a …\nLoad four 16-bit integers and zero extend each one to a …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise signed integers, and returns the …\nCompares lane-wise signed integers, and returns the …\nMultiplies two 128-bit vectors as if they were two packed …\nCompares two 128-bit vectors as if they were two vectors …\nNegates a 128-bit vectors interpreted as four 32-bit …\nSimilar to <code>i16x8_relaxed_dot_i8x16_i7x16</code> except that the …\nA relaxed version of <code>v128_bitselect</code> where this either …\nA relaxed version of <code>i32x4_trunc_sat_f32x4(a)</code> converts the …\nA relaxed version of <code>i32x4_trunc_sat_f64x2_zero(a)</code> …\nReplaces a lane from a 128-bit vector interpreted as 4 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nConverts a 128-bit vector interpreted as four 32-bit …\nSaturating conversion of the two double-precision floating …\nMaterializes a SIMD value from the provided operands.\nLane-wise wrapping absolute value.\nAdds two 128-bit vectors as if they were two packed two …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nConverts high half of the smaller lane vector to a larger …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 2 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLoad two 32-bit integers and sign extend each one to a …\nLoad two 32-bit integers and zero extend each one to a …\nCompares two 128-bit vectors as if they were two vectors …\nMultiplies two 128-bit vectors as if they were two packed …\nCompares two 128-bit vectors as if they were two vectors …\nNegates a 128-bit vectors interpreted as two 64-bit signed …\nA relaxed version of <code>v128_bitselect</code> where this either …\nReplaces a lane from a 128-bit vector interpreted as 2 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nMaterializes a SIMD value from the provided operands.\nLane-wise wrapping absolute value.\nAdds two 128-bit vectors as if they were two packed …\nAdds two 128-bit vectors as if they were two packed …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nExtracts a lane from a 128-bit vector interpreted as 16 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise signed integers, and returns the …\nCompares lane-wise signed integers, and returns the …\nConverts two input vectors into a smaller lane vector by …\nCompares two 128-bit vectors as if they were two vectors …\nNegates a 128-bit vectors interpreted as sixteen 8-bit …\nCount the number of bits set to one within each lane.\nA relaxed version of <code>v128_bitselect</code> where this either …\nA relaxed version of <code>i8x16_swizzle(a, s)</code> which selects …\nReplaces a lane from a 128-bit vector interpreted as 16 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nReturns a new vector with lanes selected from the lanes of …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nSubtracts two 128-bit vectors as if they were two packed …\nReturns a new vector with lanes selected from the lanes of …\nCorresponding intrinsic to wasm’s <code>memory.atomic.notify</code> …\nCorresponding intrinsic to wasm’s <code>memory.atomic.wait32</code> …\nCorresponding intrinsic to wasm’s <code>memory.atomic.wait64</code> …\nCorresponding intrinsic to wasm’s <code>memory.grow</code> instruction\nCorresponding intrinsic to wasm’s <code>memory.size</code> instruction\nGenerates the <code>throw</code> instruction from the …\nMaterializes a SIMD value from the provided operands.\nAdds two 128-bit vectors as if they were two packed eight …\nAdds two 128-bit vectors as if they were two packed eight …\nReturns true if all lanes are non-zero, false otherwise.\nLane-wise rounding average.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nInteger extended pairwise addition producing extended …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 8 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLoad eight 8-bit integers and zero extend each one to a …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise unsigned integers, and returns the …\nCompares lane-wise unsigned integers, and returns the …\nMultiplies two 128-bit vectors as if they were two packed …\nConverts two input vectors into a smaller lane vector by …\nCompares two 128-bit vectors as if they were two vectors …\nA relaxed dot-product instruction.\nA relaxed version of <code>v128_bitselect</code> where this either …\nA relaxed version of <code>i16x8_relaxed_q15mulr</code> where if both …\nReplaces a lane from a 128-bit vector interpreted as 8 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nSubtracts two 128-bit vectors as if they were two packed …\nMaterializes a SIMD value from the provided operands.\nAdds two 128-bit vectors as if they were two packed four …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nInteger extended pairwise addition producing extended …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 4 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLoad four 16-bit integers and zero extend each one to a …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise unsigned integers, and returns the …\nCompares lane-wise unsigned integers, and returns the …\nMultiplies two 128-bit vectors as if they were two packed …\nCompares two 128-bit vectors as if they were two vectors …\nSimilar to <code>i16x8_relaxed_dot_i8x16_i7x16</code> except that the …\nA relaxed version of <code>v128_bitselect</code> where this either …\nA relaxed version of <code>u32x4_trunc_sat_f32x4(a)</code> converts the …\nA relaxed version of <code>u32x4_trunc_sat_f64x2_zero(a)</code> …\nReplaces a lane from a 128-bit vector interpreted as 4 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nConverts a 128-bit vector interpreted as four 32-bit …\nSaturating conversion of the two double-precision floating …\nMaterializes a SIMD value from the provided operands.\nAdds two 128-bit vectors as if they were two packed two …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 2 …\nLoad two 32-bit integers and zero extend each one to a …\nMultiplies two 128-bit vectors as if they were two packed …\nCompares two 128-bit vectors as if they were two vectors …\nA relaxed version of <code>v128_bitselect</code> where this either …\nReplaces a lane from a 128-bit vector interpreted as 2 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nMaterializes a SIMD value from the provided operands.\nAdds two 128-bit vectors as if they were two packed …\nAdds two 128-bit vectors as if they were two packed …\nReturns true if all lanes are non-zero, false otherwise.\nLane-wise rounding average.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nExtracts a lane from a 128-bit vector interpreted as 16 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise unsigned integers, and returns the …\nCompares lane-wise unsigned integers, and returns the …\nConverts two input vectors into a smaller lane vector by …\nCompares two 128-bit vectors as if they were two vectors …\nCount the number of bits set to one within each lane.\nA relaxed version of <code>v128_bitselect</code> where this either …\nA relaxed version of <code>i8x16_swizzle(a, s)</code> which selects …\nReplaces a lane from a 128-bit vector interpreted as 16 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nReturns a new vector with lanes selected from the lanes of …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nSubtracts two 128-bit vectors as if they were two packed …\nReturns a new vector with lanes selected from the lanes of …\nGenerates the <code>unreachable</code> instruction, which causes an …\nWASM-specific 128-bit wide SIMD vector type.\nPerforms a bitwise and of the two input 128-bit vectors, …\nBitwise AND of bits of <code>a</code> and the logical inverse of bits …\nReturns <code>true</code> if any bit in <code>a</code> is set, or <code>false</code> otherwise.\nUse the bitmask in <code>c</code> to select bits from <code>v1</code> when 1 and <code>v2</code> …\nLoads a <code>v128</code> vector from the given heap address.\nLoads a 16-bit value from <code>m</code> and sets lane <code>L</code> of <code>v</code> to that …\nLoad a single element and splat to all lanes of a v128 …\nLoads a 32-bit value from <code>m</code> and sets lane <code>L</code> of <code>v</code> to that …\nLoad a single element and splat to all lanes of a v128 …\nLoad a 32-bit element into the low bits of the vector and …\nLoads a 64-bit value from <code>m</code> and sets lane <code>L</code> of <code>v</code> to that …\nLoad a single element and splat to all lanes of a v128 …\nLoad a 64-bit element into the low bits of the vector and …\nLoads an 8-bit value from <code>m</code> and sets lane <code>L</code> of <code>v</code> to that …\nLoad a single element and splat to all lanes of a v128 …\nFlips each bit of the 128-bit input vector.\nPerforms a bitwise or of the two input 128-bit vectors, …\nStores a <code>v128</code> vector to the given heap address.\nStores the 16-bit value from lane <code>L</code> of <code>v</code> into <code>m</code>\nStores the 32-bit value from lane <code>L</code> of <code>v</code> into <code>m</code>\nStores the 64-bit value from lane <code>L</code> of <code>v</code> into <code>m</code>\nStores the 8-bit value from lane <code>L</code> of <code>v</code> into <code>m</code>\nPerforms a bitwise xor of the two input 128-bit vectors, …\nGenerates the <code>f32.ceil</code> instruction, returning the smallest …\nGenerates the <code>f32.floor</code> instruction, returning the largest …\nGenerates the <code>f32.nearest</code> instruction, roundinging to the …\nGenerates the <code>f32.sqrt</code> instruction, returning the square …\nGenerates the <code>f32.trunc</code> instruction, roundinging to the …\nMaterializes a SIMD value from the provided operands.\nCalculates the absolute value of each lane of a 128-bit …\nLane-wise addition of two 128-bit vectors interpreted as …\nLane-wise rounding to the nearest integral value not …\nConverts a 128-bit vector interpreted as four 32-bit …\nConverts a 128-bit vector interpreted as four 32-bit …\nConversion of the two double-precision floating point …\nLane-wise division of two 128-bit vectors interpreted as …\nCompares two 128-bit vectors as if they were two vectors …\nExtracts a lane from a 128-bit vector interpreted as 4 …\nLane-wise rounding to the nearest integral value not …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCalculates the lane-wise minimum of two 128-bit vectors …\nCalculates the lane-wise minimum of two 128-bit vectors …\nLane-wise multiplication of two 128-bit vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLane-wise rounding to the nearest integral value; if two …\nNegates each lane of a 128-bit vector interpreted as four …\nLane-wise maximum value, defined as <code>a &lt; b ? b : a</code>\nLane-wise minimum value, defined as <code>b &lt; a ? b : a</code>\nComputes <code>a * b + c</code> with either one rounding or two …\nA relaxed version of <code>f32x4_max</code> which is either <code>f32x4_max</code> or\nA relaxed version of <code>f32x4_min</code> which is either <code>f32x4_min</code> or\nComputes <code>-a * b + c</code> with either one rounding or two …\nReplaces a lane from a 128-bit vector interpreted as 4 …\nCreates a vector with identical lanes.\nCalculates the square root of each lane of a 128-bit …\nLane-wise subtraction of two 128-bit vectors interpreted …\nLane-wise rounding to the nearest integral value with the …\nGenerates the <code>f64.ceil</code> instruction, returning the smallest …\nGenerates the <code>f64.floor</code> instruction, returning the largest …\nGenerates the <code>f64.nearest</code> instruction, roundinging to the …\nGenerates the <code>f64.sqrt</code> instruction, returning the square …\nGenerates the <code>f64.trunc</code> instruction, roundinging to the …\nMaterializes a SIMD value from the provided operands.\nCalculates the absolute value of each lane of a 128-bit …\nLane-wise add of two 128-bit vectors interpreted as two …\nLane-wise rounding to the nearest integral value not …\nLane-wise conversion from integer to floating point.\nLane-wise conversion from integer to floating point.\nLane-wise divide of two 128-bit vectors interpreted as two …\nCompares two 128-bit vectors as if they were two vectors …\nExtracts a lane from a 128-bit vector interpreted as 2 …\nLane-wise rounding to the nearest integral value not …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCalculates the lane-wise maximum of two 128-bit vectors …\nCalculates the lane-wise minimum of two 128-bit vectors …\nLane-wise multiply of two 128-bit vectors interpreted as …\nCompares two 128-bit vectors as if they were two vectors …\nLane-wise rounding to the nearest integral value; if two …\nNegates each lane of a 128-bit vector interpreted as two …\nLane-wise maximum value, defined as <code>a &lt; b ? b : a</code>\nLane-wise minimum value, defined as <code>b &lt; a ? b : a</code>\nConversion of the two lower single-precision floating …\nComputes <code>a * b + c</code> with either one rounding or two …\nA relaxed version of <code>f64x2_max</code> which is either <code>f64x2_max</code> or\nA relaxed version of <code>f64x2_min</code> which is either <code>f64x2_min</code> or\nComputes <code>-a * b + c</code> with either one rounding or two …\nReplaces a lane from a 128-bit vector interpreted as 2 …\nCreates a vector with identical lanes.\nCalculates the square root of each lane of a 128-bit …\nLane-wise subtract of two 128-bit vectors interpreted as …\nLane-wise rounding to the nearest integral value with the …\nReturns the argument unchanged.\nMaterializes a SIMD value from the provided operands.\nLane-wise wrapping absolute value.\nAdds two 128-bit vectors as if they were two packed eight …\nAdds two 128-bit vectors as if they were two packed eight …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nInteger extended pairwise addition producing extended …\nInteger extended pairwise addition producing extended …\nConverts high half of the smaller lane vector to a larger …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 8 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLoad eight 8-bit integers and sign extend each one to a …\nLoad eight 8-bit integers and zero extend each one to a …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise signed integers, and returns the …\nCompares lane-wise signed integers, and returns the …\nMultiplies two 128-bit vectors as if they were two packed …\nConverts two input vectors into a smaller lane vector by …\nCompares two 128-bit vectors as if they were two vectors …\nNegates a 128-bit vectors interpreted as eight 16-bit …\nLane-wise saturating rounding multiplication in Q15 format.\nA relaxed dot-product instruction.\nA relaxed version of <code>v128_bitselect</code> where this either …\nA relaxed version of <code>i16x8_relaxed_q15mulr</code> where if both …\nReplaces a lane from a 128-bit vector interpreted as 8 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nSubtracts two 128-bit vectors as if they were two packed …\nMaterializes a SIMD value from the provided operands.\nLane-wise wrapping absolute value.\nAdds two 128-bit vectors as if they were two packed four …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nLane-wise multiply signed 16-bit integers in the two input …\nCompares two 128-bit vectors as if they were two vectors …\nInteger extended pairwise addition producing extended …\nInteger extended pairwise addition producing extended …\nConverts high half of the smaller lane vector to a larger …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 4 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLoad four 16-bit integers and sign extend each one to a …\nLoad four 16-bit integers and zero extend each one to a …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise signed integers, and returns the …\nCompares lane-wise signed integers, and returns the …\nMultiplies two 128-bit vectors as if they were two packed …\nCompares two 128-bit vectors as if they were two vectors …\nNegates a 128-bit vectors interpreted as four 32-bit …\nSimilar to <code>i16x8_relaxed_dot_i8x16_i7x16</code> except that the …\nA relaxed version of <code>v128_bitselect</code> where this either …\nA relaxed version of <code>i32x4_trunc_sat_f32x4(a)</code> converts the …\nA relaxed version of <code>i32x4_trunc_sat_f64x2_zero(a)</code> …\nReplaces a lane from a 128-bit vector interpreted as 4 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nConverts a 128-bit vector interpreted as four 32-bit …\nSaturating conversion of the two double-precision floating …\nMaterializes a SIMD value from the provided operands.\nLane-wise wrapping absolute value.\nAdds two 128-bit vectors as if they were two packed two …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nConverts high half of the smaller lane vector to a larger …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 2 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLoad two 32-bit integers and sign extend each one to a …\nLoad two 32-bit integers and zero extend each one to a …\nCompares two 128-bit vectors as if they were two vectors …\nMultiplies two 128-bit vectors as if they were two packed …\nCompares two 128-bit vectors as if they were two vectors …\nNegates a 128-bit vectors interpreted as two 64-bit signed …\nA relaxed version of <code>v128_bitselect</code> where this either …\nReplaces a lane from a 128-bit vector interpreted as 2 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nMaterializes a SIMD value from the provided operands.\nLane-wise wrapping absolute value.\nAdds two 128-bit vectors as if they were two packed …\nAdds two 128-bit vectors as if they were two packed …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nExtracts a lane from a 128-bit vector interpreted as 16 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise signed integers, and returns the …\nCompares lane-wise signed integers, and returns the …\nConverts two input vectors into a smaller lane vector by …\nCompares two 128-bit vectors as if they were two vectors …\nNegates a 128-bit vectors interpreted as sixteen 8-bit …\nCount the number of bits set to one within each lane.\nA relaxed version of <code>v128_bitselect</code> where this either …\nA relaxed version of <code>i8x16_swizzle(a, s)</code> which selects …\nReplaces a lane from a 128-bit vector interpreted as 16 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nReturns a new vector with lanes selected from the lanes of …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nSubtracts two 128-bit vectors as if they were two packed …\nReturns a new vector with lanes selected from the lanes of …\nCalls <code>U::from(self)</code>.\nCorresponding intrinsic to wasm’s <code>memory.atomic.notify</code> …\nCorresponding intrinsic to wasm’s <code>memory.atomic.wait32</code> …\nCorresponding intrinsic to wasm’s <code>memory.atomic.wait64</code> …\nCorresponding intrinsic to wasm’s <code>memory.grow</code> instruction\nCorresponding intrinsic to wasm’s <code>memory.size</code> instruction\nGenerates the <code>throw</code> instruction from the …\nMaterializes a SIMD value from the provided operands.\nAdds two 128-bit vectors as if they were two packed eight …\nAdds two 128-bit vectors as if they were two packed eight …\nReturns true if all lanes are non-zero, false otherwise.\nLane-wise rounding average.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nInteger extended pairwise addition producing extended …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 8 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLoad eight 8-bit integers and zero extend each one to a …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise unsigned integers, and returns the …\nCompares lane-wise unsigned integers, and returns the …\nMultiplies two 128-bit vectors as if they were two packed …\nConverts two input vectors into a smaller lane vector by …\nCompares two 128-bit vectors as if they were two vectors …\nA relaxed dot-product instruction.\nA relaxed version of <code>v128_bitselect</code> where this either …\nA relaxed version of <code>i16x8_relaxed_q15mulr</code> where if both …\nReplaces a lane from a 128-bit vector interpreted as 8 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nSubtracts two 128-bit vectors as if they were two packed …\nMaterializes a SIMD value from the provided operands.\nAdds two 128-bit vectors as if they were two packed four …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nInteger extended pairwise addition producing extended …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 4 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLoad four 16-bit integers and zero extend each one to a …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise unsigned integers, and returns the …\nCompares lane-wise unsigned integers, and returns the …\nMultiplies two 128-bit vectors as if they were two packed …\nCompares two 128-bit vectors as if they were two vectors …\nSimilar to <code>i16x8_relaxed_dot_i8x16_i7x16</code> except that the …\nA relaxed version of <code>v128_bitselect</code> where this either …\nA relaxed version of <code>u32x4_trunc_sat_f32x4(a)</code> converts the …\nA relaxed version of <code>u32x4_trunc_sat_f64x2_zero(a)</code> …\nReplaces a lane from a 128-bit vector interpreted as 4 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nConverts a 128-bit vector interpreted as four 32-bit …\nSaturating conversion of the two double-precision floating …\nMaterializes a SIMD value from the provided operands.\nAdds two 128-bit vectors as if they were two packed two …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 2 …\nLoad two 32-bit integers and zero extend each one to a …\nMultiplies two 128-bit vectors as if they were two packed …\nCompares two 128-bit vectors as if they were two vectors …\nA relaxed version of <code>v128_bitselect</code> where this either …\nReplaces a lane from a 128-bit vector interpreted as 2 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nMaterializes a SIMD value from the provided operands.\nAdds two 128-bit vectors as if they were two packed …\nAdds two 128-bit vectors as if they were two packed …\nReturns true if all lanes are non-zero, false otherwise.\nLane-wise rounding average.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nExtracts a lane from a 128-bit vector interpreted as 16 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise unsigned integers, and returns the …\nCompares lane-wise unsigned integers, and returns the …\nConverts two input vectors into a smaller lane vector by …\nCompares two 128-bit vectors as if they were two vectors …\nCount the number of bits set to one within each lane.\nA relaxed version of <code>v128_bitselect</code> where this either …\nA relaxed version of <code>i8x16_swizzle(a, s)</code> which selects …\nReplaces a lane from a 128-bit vector interpreted as 16 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nReturns a new vector with lanes selected from the lanes of …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nSubtracts two 128-bit vectors as if they were two packed …\nReturns a new vector with lanes selected from the lanes of …\nGenerates the <code>unreachable</code> instruction, which causes an …\nWASM-specific 128-bit wide SIMD vector type.\nPerforms a bitwise and of the two input 128-bit vectors, …\nBitwise AND of bits of <code>a</code> and the logical inverse of bits …\nReturns <code>true</code> if any bit in <code>a</code> is set, or <code>false</code> otherwise.\nUse the bitmask in <code>c</code> to select bits from <code>v1</code> when 1 and <code>v2</code> …\nLoads a <code>v128</code> vector from the given heap address.\nLoads a 16-bit value from <code>m</code> and sets lane <code>L</code> of <code>v</code> to that …\nLoad a single element and splat to all lanes of a v128 …\nLoads a 32-bit value from <code>m</code> and sets lane <code>L</code> of <code>v</code> to that …\nLoad a single element and splat to all lanes of a v128 …\nLoad a 32-bit element into the low bits of the vector and …\nLoads a 64-bit value from <code>m</code> and sets lane <code>L</code> of <code>v</code> to that …\nLoad a single element and splat to all lanes of a v128 …\nLoad a 64-bit element into the low bits of the vector and …\nLoads an 8-bit value from <code>m</code> and sets lane <code>L</code> of <code>v</code> to that …\nLoad a single element and splat to all lanes of a v128 …\nFlips each bit of the 128-bit input vector.\nPerforms a bitwise or of the two input 128-bit vectors, …\nStores a <code>v128</code> vector to the given heap address.\nStores the 16-bit value from lane <code>L</code> of <code>v</code> into <code>m</code>\nStores the 32-bit value from lane <code>L</code> of <code>v</code> into <code>m</code>\nStores the 64-bit value from lane <code>L</code> of <code>v</code> into <code>m</code>\nStores the 8-bit value from lane <code>L</code> of <code>v</code> into <code>m</code>\nPerforms a bitwise xor of the two input 128-bit vectors, …\nGenerates the <code>f32.ceil</code> instruction, returning the smallest …\nGenerates the <code>f32.floor</code> instruction, returning the largest …\nGenerates the <code>f32.nearest</code> instruction, roundinging to the …\nGenerates the <code>f32.sqrt</code> instruction, returning the square …\nGenerates the <code>f32.trunc</code> instruction, roundinging to the …\nMaterializes a SIMD value from the provided operands.\nCalculates the absolute value of each lane of a 128-bit …\nLane-wise addition of two 128-bit vectors interpreted as …\nLane-wise rounding to the nearest integral value not …\nConverts a 128-bit vector interpreted as four 32-bit …\nConverts a 128-bit vector interpreted as four 32-bit …\nConversion of the two double-precision floating point …\nLane-wise division of two 128-bit vectors interpreted as …\nCompares two 128-bit vectors as if they were two vectors …\nExtracts a lane from a 128-bit vector interpreted as 4 …\nLane-wise rounding to the nearest integral value not …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCalculates the lane-wise minimum of two 128-bit vectors …\nCalculates the lane-wise minimum of two 128-bit vectors …\nLane-wise multiplication of two 128-bit vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLane-wise rounding to the nearest integral value; if two …\nNegates each lane of a 128-bit vector interpreted as four …\nLane-wise maximum value, defined as <code>a &lt; b ? b : a</code>\nLane-wise minimum value, defined as <code>b &lt; a ? b : a</code>\nComputes <code>a * b + c</code> with either one rounding or two …\nA relaxed version of <code>f32x4_max</code> which is either <code>f32x4_max</code> or\nA relaxed version of <code>f32x4_min</code> which is either <code>f32x4_min</code> or\nComputes <code>-a * b + c</code> with either one rounding or two …\nReplaces a lane from a 128-bit vector interpreted as 4 …\nCreates a vector with identical lanes.\nCalculates the square root of each lane of a 128-bit …\nLane-wise subtraction of two 128-bit vectors interpreted …\nLane-wise rounding to the nearest integral value with the …\nGenerates the <code>f64.ceil</code> instruction, returning the smallest …\nGenerates the <code>f64.floor</code> instruction, returning the largest …\nGenerates the <code>f64.nearest</code> instruction, roundinging to the …\nGenerates the <code>f64.sqrt</code> instruction, returning the square …\nGenerates the <code>f64.trunc</code> instruction, roundinging to the …\nMaterializes a SIMD value from the provided operands.\nCalculates the absolute value of each lane of a 128-bit …\nLane-wise add of two 128-bit vectors interpreted as two …\nLane-wise rounding to the nearest integral value not …\nLane-wise conversion from integer to floating point.\nLane-wise conversion from integer to floating point.\nLane-wise divide of two 128-bit vectors interpreted as two …\nCompares two 128-bit vectors as if they were two vectors …\nExtracts a lane from a 128-bit vector interpreted as 2 …\nLane-wise rounding to the nearest integral value not …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCalculates the lane-wise maximum of two 128-bit vectors …\nCalculates the lane-wise minimum of two 128-bit vectors …\nLane-wise multiply of two 128-bit vectors interpreted as …\nCompares two 128-bit vectors as if they were two vectors …\nLane-wise rounding to the nearest integral value; if two …\nNegates each lane of a 128-bit vector interpreted as two …\nLane-wise maximum value, defined as <code>a &lt; b ? b : a</code>\nLane-wise minimum value, defined as <code>b &lt; a ? b : a</code>\nConversion of the two lower single-precision floating …\nComputes <code>a * b + c</code> with either one rounding or two …\nA relaxed version of <code>f64x2_max</code> which is either <code>f64x2_max</code> or\nA relaxed version of <code>f64x2_min</code> which is either <code>f64x2_min</code> or\nComputes <code>-a * b + c</code> with either one rounding or two …\nReplaces a lane from a 128-bit vector interpreted as 2 …\nCreates a vector with identical lanes.\nCalculates the square root of each lane of a 128-bit …\nLane-wise subtract of two 128-bit vectors interpreted as …\nLane-wise rounding to the nearest integral value with the …\nMaterializes a SIMD value from the provided operands.\nLane-wise wrapping absolute value.\nAdds two 128-bit vectors as if they were two packed eight …\nAdds two 128-bit vectors as if they were two packed eight …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nInteger extended pairwise addition producing extended …\nInteger extended pairwise addition producing extended …\nConverts high half of the smaller lane vector to a larger …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 8 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLoad eight 8-bit integers and sign extend each one to a …\nLoad eight 8-bit integers and zero extend each one to a …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise signed integers, and returns the …\nCompares lane-wise signed integers, and returns the …\nMultiplies two 128-bit vectors as if they were two packed …\nConverts two input vectors into a smaller lane vector by …\nCompares two 128-bit vectors as if they were two vectors …\nNegates a 128-bit vectors interpreted as eight 16-bit …\nLane-wise saturating rounding multiplication in Q15 format.\nA relaxed dot-product instruction.\nA relaxed version of <code>v128_bitselect</code> where this either …\nA relaxed version of <code>i16x8_relaxed_q15mulr</code> where if both …\nReplaces a lane from a 128-bit vector interpreted as 8 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nSubtracts two 128-bit vectors as if they were two packed …\nMaterializes a SIMD value from the provided operands.\nLane-wise wrapping absolute value.\nAdds two 128-bit vectors as if they were two packed four …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nLane-wise multiply signed 16-bit integers in the two input …\nCompares two 128-bit vectors as if they were two vectors …\nInteger extended pairwise addition producing extended …\nInteger extended pairwise addition producing extended …\nConverts high half of the smaller lane vector to a larger …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 4 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLoad four 16-bit integers and sign extend each one to a …\nLoad four 16-bit integers and zero extend each one to a …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise signed integers, and returns the …\nCompares lane-wise signed integers, and returns the …\nMultiplies two 128-bit vectors as if they were two packed …\nCompares two 128-bit vectors as if they were two vectors …\nNegates a 128-bit vectors interpreted as four 32-bit …\nSimilar to <code>i16x8_relaxed_dot_i8x16_i7x16</code> except that the …\nA relaxed version of <code>v128_bitselect</code> where this either …\nA relaxed version of <code>i32x4_trunc_sat_f32x4(a)</code> converts the …\nA relaxed version of <code>i32x4_trunc_sat_f64x2_zero(a)</code> …\nReplaces a lane from a 128-bit vector interpreted as 4 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nConverts a 128-bit vector interpreted as four 32-bit …\nSaturating conversion of the two double-precision floating …\nMaterializes a SIMD value from the provided operands.\nLane-wise wrapping absolute value.\nAdds two 128-bit vectors as if they were two packed two …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nConverts high half of the smaller lane vector to a larger …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 2 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLoad two 32-bit integers and sign extend each one to a …\nLoad two 32-bit integers and zero extend each one to a …\nCompares two 128-bit vectors as if they were two vectors …\nMultiplies two 128-bit vectors as if they were two packed …\nCompares two 128-bit vectors as if they were two vectors …\nNegates a 128-bit vectors interpreted as two 64-bit signed …\nA relaxed version of <code>v128_bitselect</code> where this either …\nReplaces a lane from a 128-bit vector interpreted as 2 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nMaterializes a SIMD value from the provided operands.\nLane-wise wrapping absolute value.\nAdds two 128-bit vectors as if they were two packed …\nAdds two 128-bit vectors as if they were two packed …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nExtracts a lane from a 128-bit vector interpreted as 16 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise signed integers, and returns the …\nCompares lane-wise signed integers, and returns the …\nConverts two input vectors into a smaller lane vector by …\nCompares two 128-bit vectors as if they were two vectors …\nNegates a 128-bit vectors interpreted as sixteen 8-bit …\nCount the number of bits set to one within each lane.\nA relaxed version of <code>v128_bitselect</code> where this either …\nA relaxed version of <code>i8x16_swizzle(a, s)</code> which selects …\nReplaces a lane from a 128-bit vector interpreted as 16 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nReturns a new vector with lanes selected from the lanes of …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nSubtracts two 128-bit vectors as if they were two packed …\nReturns a new vector with lanes selected from the lanes of …\nCorresponding intrinsic to wasm’s <code>memory.atomic.notify</code> …\nCorresponding intrinsic to wasm’s <code>memory.atomic.wait32</code> …\nCorresponding intrinsic to wasm’s <code>memory.atomic.wait64</code> …\nCorresponding intrinsic to wasm’s <code>memory.grow</code> instruction\nCorresponding intrinsic to wasm’s <code>memory.size</code> instruction\nGenerates the <code>throw</code> instruction from the …\nMaterializes a SIMD value from the provided operands.\nAdds two 128-bit vectors as if they were two packed eight …\nAdds two 128-bit vectors as if they were two packed eight …\nReturns true if all lanes are non-zero, false otherwise.\nLane-wise rounding average.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nInteger extended pairwise addition producing extended …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 8 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLoad eight 8-bit integers and zero extend each one to a …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise unsigned integers, and returns the …\nCompares lane-wise unsigned integers, and returns the …\nMultiplies two 128-bit vectors as if they were two packed …\nConverts two input vectors into a smaller lane vector by …\nCompares two 128-bit vectors as if they were two vectors …\nA relaxed dot-product instruction.\nA relaxed version of <code>v128_bitselect</code> where this either …\nA relaxed version of <code>i16x8_relaxed_q15mulr</code> where if both …\nReplaces a lane from a 128-bit vector interpreted as 8 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nSubtracts two 128-bit vectors as if they were two packed …\nMaterializes a SIMD value from the provided operands.\nAdds two 128-bit vectors as if they were two packed four …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nInteger extended pairwise addition producing extended …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 4 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLoad four 16-bit integers and zero extend each one to a …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise unsigned integers, and returns the …\nCompares lane-wise unsigned integers, and returns the …\nMultiplies two 128-bit vectors as if they were two packed …\nCompares two 128-bit vectors as if they were two vectors …\nSimilar to <code>i16x8_relaxed_dot_i8x16_i7x16</code> except that the …\nA relaxed version of <code>v128_bitselect</code> where this either …\nA relaxed version of <code>u32x4_trunc_sat_f32x4(a)</code> converts the …\nA relaxed version of <code>u32x4_trunc_sat_f64x2_zero(a)</code> …\nReplaces a lane from a 128-bit vector interpreted as 4 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nConverts a 128-bit vector interpreted as four 32-bit …\nSaturating conversion of the two double-precision floating …\nMaterializes a SIMD value from the provided operands.\nAdds two 128-bit vectors as if they were two packed two …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 2 …\nLoad two 32-bit integers and zero extend each one to a …\nMultiplies two 128-bit vectors as if they were two packed …\nCompares two 128-bit vectors as if they were two vectors …\nA relaxed version of <code>v128_bitselect</code> where this either …\nReplaces a lane from a 128-bit vector interpreted as 2 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nMaterializes a SIMD value from the provided operands.\nAdds two 128-bit vectors as if they were two packed …\nAdds two 128-bit vectors as if they were two packed …\nReturns true if all lanes are non-zero, false otherwise.\nLane-wise rounding average.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nExtracts a lane from a 128-bit vector interpreted as 16 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise unsigned integers, and returns the …\nCompares lane-wise unsigned integers, and returns the …\nConverts two input vectors into a smaller lane vector by …\nCompares two 128-bit vectors as if they were two vectors …\nCount the number of bits set to one within each lane.\nA relaxed version of <code>v128_bitselect</code> where this either …\nA relaxed version of <code>i8x16_swizzle(a, s)</code> which selects …\nReplaces a lane from a 128-bit vector interpreted as 16 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nReturns a new vector with lanes selected from the lanes of …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nSubtracts two 128-bit vectors as if they were two packed …\nReturns a new vector with lanes selected from the lanes of …\nGenerates the <code>unreachable</code> instruction, which causes an …\nWASM-specific 128-bit wide SIMD vector type.\nPerforms a bitwise and of the two input 128-bit vectors, …\nBitwise AND of bits of <code>a</code> and the logical inverse of bits …\nReturns <code>true</code> if any bit in <code>a</code> is set, or <code>false</code> otherwise.\nUse the bitmask in <code>c</code> to select bits from <code>v1</code> when 1 and <code>v2</code> …\nLoads a <code>v128</code> vector from the given heap address.\nLoads a 16-bit value from <code>m</code> and sets lane <code>L</code> of <code>v</code> to that …\nLoad a single element and splat to all lanes of a v128 …\nLoads a 32-bit value from <code>m</code> and sets lane <code>L</code> of <code>v</code> to that …\nLoad a single element and splat to all lanes of a v128 …\nLoad a 32-bit element into the low bits of the vector and …\nLoads a 64-bit value from <code>m</code> and sets lane <code>L</code> of <code>v</code> to that …\nLoad a single element and splat to all lanes of a v128 …\nLoad a 64-bit element into the low bits of the vector and …\nLoads an 8-bit value from <code>m</code> and sets lane <code>L</code> of <code>v</code> to that …\nLoad a single element and splat to all lanes of a v128 …\nFlips each bit of the 128-bit input vector.\nPerforms a bitwise or of the two input 128-bit vectors, …\nStores a <code>v128</code> vector to the given heap address.\nStores the 16-bit value from lane <code>L</code> of <code>v</code> into <code>m</code>\nStores the 32-bit value from lane <code>L</code> of <code>v</code> into <code>m</code>\nStores the 64-bit value from lane <code>L</code> of <code>v</code> into <code>m</code>\nStores the 8-bit value from lane <code>L</code> of <code>v</code> into <code>m</code>\nPerforms a bitwise xor of the two input 128-bit vectors, …\nResult of the <code>cpuid</code> instruction.\nEqual (ordered, non-signaling)\nEqual (ordered, signaling)\nEqual (unordered, non-signaling)\nEqual (unordered, signaling)\nFalse (ordered, non-signaling)\nFalse (ordered, signaling)\nGreater-than-or-equal (ordered, non-signaling)\nGreater-than-or-equal (ordered, signaling)\nGreater-than (ordered, non-signaling)\nGreater-than (ordered, signaling)\nLess-than-or-equal (ordered, non-signaling)\nLess-than-or-equal (ordered, signaling)\nLess-than (ordered, non-signaling)\nLess-than (ordered, signaling)\nNot-equal (ordered, non-signaling)\nNot-equal (ordered, signaling)\nNot-equal (unordered, non-signaling)\nNot-equal (unordered, signaling)\nNot-greater-than-or-equal (unordered, non-signaling)\nNot-greater-than-or-equal (unordered, signaling)\nNot-greater-than (unordered, non-signaling)\nNot-greater-than (unordered, signaling)\nNot-less-than-or-equal (unordered, non-signaling)\nNot-less-than-or-equal (unordered, signaling)\nNot-less-than (unordered, non-signaling)\nNot-less-than (unordered, signaling)\nOrdered (non-signaling)\nOrdered (signaling)\nTrue (unordered, non-signaling)\nTrue (unordered, signaling)\nUnordered (non-signaling)\nUnordered (signaling)\nThe <code>_MM_CMPINT_ENUM</code> type used to specify comparison …\nEqual\nFalse\nLess-than-or-equal\nLess-than\nNot-equal\nNot less-than-or-equal\nNot less-than\nTrue\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_MM_GET_EXCEPTION_STATE</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_MM_GET_FLUSH_ZERO_MODE</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nround up and do not suppress exceptions\nuse MXCSR.RC; see <code>vendor::_MM_SET_ROUNDING_MODE</code>\nround down and do not suppress exceptions\nuse MXCSR.RC and suppress exceptions; see …\nround to nearest and do not suppress exceptions\nsuppress exceptions\ndo not suppress exceptions\nuse MXCSR.RC and do not suppress exceptions; see …\nround to nearest\nround down\nround up\ntruncate\ntruncate and do not suppress exceptions\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_prefetch</code>.\nSee <code>_mm_prefetch</code>.\nSee <code>_mm_prefetch</code>.\nSee <code>_mm_prefetch</code>.\nSee <code>_mm_prefetch</code>.\nSee <code>_mm_prefetch</code>.\nThe <code>MM_MANTISSA_NORM_ENUM</code> type used to specify mantissa …\nThe <code>MM_MANTISSA_SIGN_ENUM</code> type used to specify mantissa …\ninterval [1, 2)\ninterval [0.5, 1)\ninterval [0.5, 2)\ninterval [0.75, 1.5)\nDEST = NaN if sign(SRC) = 1\nsign = sign(SRC)\nsign = 0\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_MM_GET_EXCEPTION_MASK</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nThe <code>MM_PERM_ENUM</code> type used to specify shuffle operations …\nSee <code>_mm_setcsr</code>\nSee <code>_MM_GET_ROUNDING_MODE</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nA utility function for creating masks to use with Intel …\nTranspose the 4x4 matrix formed by 4 rows of __m128 in …\n<strong>Mask only</strong>: return the bit mask\nFor each character in <code>a</code>, find if it is in <code>b</code> <em>(Default)</em>\nThe strings defined by <code>a</code> and <code>b</code> are equal\nSearch for the defined substring in the target\nFor each character in <code>a</code>, determine if …\n<strong>Index only</strong>: return the least significant bit <em>(Default)</em>\nNegates results only before the end of the string\nDo not negate results before the end of the string\n<strong>Index only</strong>: return the most significant bit\nNegates results\nDo not negate results <em>(Default)</em>\nString contains signed 8-bit characters\nString contains unsigned 16-bit characters\nString contains unsigned 8-bit characters <em>(Default)</em>\n<strong>Mask only</strong>: return the byte mask\nString contains unsigned 16-bit characters\nTransaction abort due to the transaction using too much …\nTransaction abort due to a memory conflict with another …\nTransaction abort due to a debug trap.\nTransaction explicitly aborted with xabort. The parameter …\nTransaction abort in a inner nested transaction.\nTransaction retry is possible.\nTransaction successfully started.\n<code>XFEATURE_ENABLED_MASK</code> for <code>XCR</code>\nSee <code>__cpuid_count</code>.\nReturns the result of the <code>cpuid</code> instruction for a given …\nReturns the highest-supported <code>leaf</code> (<code>EAX</code>) and sub-leaf (<code>ECX</code>…\n128-bit wide set of four <code>f32</code> types, x86-specific\n128-bit wide set of eight <code>u16</code> types, x86-specific\n128-bit wide set of two <code>f64</code> types, x86-specific\n128-bit wide set of 8 <code>f16</code> types, x86-specific\n128-bit wide integer vector type, x86-specific\n256-bit wide set of eight <code>f32</code> types, x86-specific\n256-bit wide set of 16 <code>u16</code> types, x86-specific\n256-bit wide set of four <code>f64</code> types, x86-specific\n256-bit wide set of 16 <code>f16</code> types, x86-specific\n256-bit wide integer vector type, x86-specific\n512-bit wide set of sixteen <code>f32</code> types, x86-specific\n512-bit wide set of 32 <code>u16</code> types, x86-specific\n512-bit wide set of eight <code>f64</code> types, x86-specific\n512-bit wide set of 32 <code>f16</code> types, x86-specific\n512-bit wide integer vector type, x86-specific\nThe <code>__mmask16</code> type used in AVX-512 intrinsics, a 16-bit …\nThe <code>__mmask32</code> type used in AVX-512 intrinsics, a 32-bit …\nThe <code>__mmask64</code> type used in AVX-512 intrinsics, a 64-bit …\nThe <code>__mmask8</code> type used in AVX-512 intrinsics, a 8-bit …\nReads the current value of the processor’s time-stamp …\nAdds unsigned 32-bit integers <code>a</code> and <code>b</code> with unsigned 8-bit …\nAdds unsigned 32-bit integers <code>a</code> and <code>b</code> with unsigned 8-bit …\nBitwise logical <code>AND</code> of inverted <code>a</code> with <code>b</code>.\nExtracts bits of <code>a</code> specified by <code>control</code> into the least …\nExtracts bits in range [<code>start</code>, <code>start</code> + <code>length</code>) from <code>a</code> into …\nExtracts bits of <code>a</code> specified by <code>control</code> into the least …\nReturns the bit in position <code>b</code> of the memory addressed by <code>p</code>.\nReturns the bit in position <code>b</code> of the memory addressed by <code>p</code>…\nReturns the bit in position <code>b</code> of the memory addressed by <code>p</code>…\nReturns the bit in position <code>b</code> of the memory addressed by <code>p</code>…\nClears all bits below the least significant zero bit of <code>x</code>.\nSets all bits of <code>x</code> to 1 except for the least significant …\nSets the least significant zero bit of <code>x</code> and clears all …\nSets the least significant zero bit of <code>x</code> and clears all …\nSets the least significant zero bit of <code>x</code>.\nSets all bits of <code>x</code> below the least significant one.\nExtracts lowest set isolated bit.\nClears least significant bit and sets all other bits.\nGets mask up to lowest set bit.\nResets the lowest set bit of <code>x</code>.\nReturns an integer with the reversed byte order of x\nZeroes higher bits of <code>a</code> &gt;= <code>index</code>.\nConvert 16-bit mask a into an integer value, and store the …\nConvert 32-bit mask a into an integer value, and store the …\nConvert 8-bit mask a to a 32-bit integer value and store …\nConvert 32-bit integer value a to an 16-bit mask and store …\nConvert integer value a into an 32-bit mask, and store the …\nConvert 32-bit integer value a to an 8-bit mask and store …\nRestores the <code>XMM</code>, <code>MMX</code>, <code>MXCSR</code>, and <code>x87</code> FPU registers from …\nSaves the <code>x87</code> FPU, <code>MMX</code> technology, <code>XMM</code>, and <code>MXCSR</code> …\nAdd 16-bit masks a and b, and store the result in dst.\nAdd 32-bit masks in a and b, and store the result in k.\nAdd 64-bit masks in a and b, and store the result in k.\nAdd 8-bit masks a and b, and store the result in dst.\nCompute the bitwise AND of 16-bit masks a and b, and store …\nCompute the bitwise AND of 32-bit masks a and b, and store …\nCompute the bitwise AND of 64-bit masks a and b, and store …\nBitwise AND of 8-bit masks a and b, and store the result …\nCompute the bitwise NOT of 16-bit masks a and then AND …\nCompute the bitwise NOT of 32-bit masks a and then AND …\nCompute the bitwise NOT of 64-bit masks a and then AND …\nBitwise AND NOT of 8-bit masks a and b, and store the …\nCompute the bitwise NOT of 16-bit mask a, and store the …\nCompute the bitwise NOT of 32-bit mask a, and store the …\nCompute the bitwise NOT of 64-bit mask a, and store the …\nBitwise NOT of 8-bit mask a, and store the result in dst.\nCompute the bitwise OR of 16-bit masks a and b, and store …\nCompute the bitwise OR of 32-bit masks a and b, and store …\nCompute the bitwise OR of 64-bit masks a and b, and store …\nBitwise OR of 8-bit masks a and b, and store the result in …\nCompute the bitwise OR of 16-bit masks a and b. If the …\nCompute the bitwise OR of 32-bit masks a and b. If the …\nCompute the bitwise OR of 64-bit masks a and b. If the …\nCompute the bitwise OR of 8-bit masks a and b. If the …\nCompute the bitwise OR of 16-bit masks a and b. If the …\nCompute the bitwise OR of 32-bit masks a and b. If the …\nCompute the bitwise OR of 64-bit masks a and b. If the …\nCompute the bitwise OR of 8-bit masks a and b. If the …\nCompute the bitwise OR of 16-bit masks a and b. If the …\nCompute the bitwise OR of 32-bit masks a and b. If the …\nCompute the bitwise OR of 64-bit masks a and b. If the …\nCompute the bitwise OR of 8-bit masks a and b. If the …\nShift 16-bit mask a left by count bits while shifting in …\nShift the bits of 32-bit mask a left by count while …\nShift the bits of 64-bit mask a left by count while …\nShift 8-bit mask a left by count bits while shifting in …\nShift 16-bit mask a right by count bits while shifting in …\nShift the bits of 32-bit mask a right by count while …")