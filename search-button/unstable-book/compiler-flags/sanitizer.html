<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>sanitizer - The Rust Unstable Book</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Unstable Book</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/rust/tree/master/src/doc/unstable-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/rust-lang/rust/edit/master/src/doc/unstable-book/src/compiler-flags/sanitizer.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="sanitizer"><a class="header" href="#sanitizer"><code>sanitizer</code></a></h1>
<p>Sanitizers are tools that help detect and prevent various types of bugs and
vulnerabilities in software. They are available in compilers and work by
instrumenting the code to add additional runtime checks. While they provide
powerful tools for identifying bugs or security issues, it's important to note
that using sanitizers can introduce runtime overhead and might not catch all
possible issues. Therefore, they are typically used alongside other best
practices in software development, such as testing and fuzzing, to ensure the
highest level of software quality and security.</p>
<p>The tracking issues for this feature are:</p>
<ul>
<li><a href="https://github.com/rust-lang/rust/issues/39699">#39699</a>.</li>
<li><a href="https://github.com/rust-lang/rust/issues/89653">#89653</a>.</li>
</ul>
<hr />
<p>This feature allows for use of one of following sanitizers:</p>
<ul>
<li>
<p>Those intended for testing or fuzzing (but not production use):</p>
<ul>
<li><a href="#addresssanitizer">AddressSanitizer</a> a fast memory error detector.</li>
<li><a href="#hwaddresssanitizer">HWAddressSanitizer</a> a memory error detector similar to
AddressSanitizer, but based on partial hardware assistance.</li>
<li><a href="#leaksanitizer">LeakSanitizer</a> a run-time memory leak detector.</li>
<li><a href="#memorysanitizer">MemorySanitizer</a> a detector of uninitialized reads.</li>
<li><a href="#threadsanitizer">ThreadSanitizer</a> a fast data race detector.</li>
</ul>
</li>
<li>
<p>Those that apart from testing, may be used in production:</p>
<ul>
<li><a href="#controlflowintegrity">ControlFlowIntegrity</a> LLVM Control Flow Integrity
(CFI) provides forward-edge control flow protection.</li>
<li><a href="#dataflowsanitizer">DataFlowSanitizer</a> a generic dynamic data flow analysis
framework.</li>
<li><a href="#kernelcontrolflowintegrity">KernelControlFlowIntegrity</a> LLVM Kernel
Control Flow Integrity (KCFI) provides forward-edge control flow protection
for operating systems kernels.</li>
<li><a href="#memtagsanitizer">MemTagSanitizer</a> fast memory error detector based on
Armv8.5-A Memory Tagging Extension.</li>
<li><a href="#safestack">SafeStack</a> provides backward-edge control flow protection by
separating the stack into safe and unsafe regions.</li>
<li><a href="#shadowcallstack">ShadowCallStack</a> provides backward-edge control flow
protection (aarch64 only).</li>
</ul>
</li>
</ul>
<p>To enable a sanitizer compile with <code>-Zsanitizer=address</code>, <code>-Zsanitizer=cfi</code>,
<code>-Zsanitizer=dataflow</code>,<code>-Zsanitizer=hwaddress</code>, <code>-Zsanitizer=leak</code>,
<code>-Zsanitizer=memory</code>, <code>-Zsanitizer=memtag</code>, <code>-Zsanitizer=shadow-call-stack</code>, or
<code>-Zsanitizer=thread</code>. You might also need the <code>--target</code> and <code>build-std</code> flags.
If you're working with other languages that are also instrumented with sanitizers,
you might need the <code>external-clangrt</code> flag. See the section on
<a href="#working-with-other-languages">working with other languages</a>.</p>
<p>Example:</p>
<pre><code class="language-shell">$ RUSTFLAGS=-Zsanitizer=address cargo build -Zbuild-std --target x86_64-unknown-linux-gnu
</code></pre>
<p>Additional options for sanitizers can be passed to LLVM command line argument
processor via LLVM arguments using <code>llvm-args</code> codegen option (e.g.,
<code>-Cllvm-args=-dfsan-combine-pointer-labels-on-load=false</code>). See the sanitizer
documentation for more information about additional options.</p>
<h1 id="addresssanitizer"><a class="header" href="#addresssanitizer">AddressSanitizer</a></h1>
<p>AddressSanitizer is a memory error detector. It can detect the following types
of bugs:</p>
<ul>
<li>Out of bound accesses to heap, stack and globals</li>
<li>Use after free</li>
<li>Use after return (runtime flag <code>ASAN_OPTIONS=detect_stack_use_after_return=1</code>)</li>
<li>Use after scope</li>
<li>Double-free, invalid free</li>
<li>Memory leaks</li>
</ul>
<p>The memory leak detection is enabled by default on Linux, and can be enabled
with runtime flag <code>ASAN_OPTIONS=detect_leaks=1</code> on macOS.</p>
<p>AddressSanitizer is supported on the following targets:</p>
<ul>
<li><code>aarch64-apple-darwin</code></li>
<li><code>aarch64-unknown-fuchsia</code></li>
<li><code>aarch64-unknown-linux-gnu</code></li>
<li><code>x86_64-apple-darwin</code></li>
<li><code>x86_64-unknown-fuchsia</code></li>
<li><code>x86_64-unknown-freebsd</code></li>
<li><code>x86_64-unknown-linux-gnu</code></li>
</ul>
<p>AddressSanitizer works with non-instrumented code although it will impede its
ability to detect some bugs.  It is not expected to produce false positive
reports.</p>
<p>See the <a href="https://clang.llvm.org/docs/AddressSanitizer.html">Clang AddressSanitizer documentation</a> for more details.</p>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<p>Stack buffer overflow:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let xs = [0, 1, 2, 3];
    let _y = unsafe { *xs.as_ptr().offset(4) };
}</code></pre></pre>
<pre><code class="language-shell">$ export RUSTFLAGS=-Zsanitizer=address RUSTDOCFLAGS=-Zsanitizer=address
$ cargo run -Zbuild-std --target x86_64-unknown-linux-gnu
==37882==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7ffe400e6250 at pc 0x5609a841fb20 bp 0x7ffe400e6210 sp 0x7ffe400e6208
READ of size 4 at 0x7ffe400e6250 thread T0
    #0 0x5609a841fb1f in example::main::h628ffc6626ed85b2 /.../src/main.rs:3:23
    ...

Address 0x7ffe400e6250 is located in stack of thread T0 at offset 48 in frame
    #0 0x5609a841f8af in example::main::h628ffc6626ed85b2 /.../src/main.rs:1

  This frame has 1 object(s):
    [32, 48) 'xs' (line 2) &lt;== Memory access at offset 48 overflows this variable
HINT: this may be a false positive if your program uses some custom stack unwind mechanism, swapcontext or vfork
      (longjmp and C++ exceptions *are* supported)
SUMMARY: AddressSanitizer: stack-buffer-overflow /.../src/main.rs:3:23 in example::main::h628ffc6626ed85b2
Shadow bytes around the buggy address:
  0x100048014bf0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100048014c00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100048014c10: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100048014c20: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100048014c30: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
=&gt;0x100048014c40: 00 00 00 00 f1 f1 f1 f1 00 00[f3]f3 00 00 00 00
  0x100048014c50: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100048014c60: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100048014c70: f1 f1 f1 f1 00 00 f3 f3 00 00 00 00 00 00 00 00
  0x100048014c80: 00 00 00 00 00 00 00 00 00 00 00 00 f1 f1 f1 f1
  0x100048014c90: 00 00 f3 f3 00 00 00 00 00 00 00 00 00 00 00 00
Shadow byte legend (one shadow byte represents 8 application bytes):
  Addressable:           00
  Partially addressable: 01 02 03 04 05 06 07
  Heap left redzone:       fa
  Freed heap region:       fd
  Stack left redzone:      f1
  Stack mid redzone:       f2
  Stack right redzone:     f3
  Stack after return:      f5
  Stack use after scope:   f8
  Global redzone:          f9
  Global init order:       f6
  Poisoned by user:        f7
  Container overflow:      fc
  Array cookie:            ac
  Intra object redzone:    bb
  ASan internal:           fe
  Left alloca redzone:     ca
  Right alloca redzone:    cb
  Shadow gap:              cc
==37882==ABORTING
</code></pre>
<p>Use of a stack object after its scope has already ended:</p>
<pre><pre class="playground"><code class="language-rust">static mut P: *mut usize = std::ptr::null_mut();

fn main() {
    unsafe {
        {
            let mut x = 0;
            P = &amp;mut x;
        }
        std::ptr::write_volatile(P, 123);
    }
}</code></pre></pre>
<pre><code class="language-shell">$ export RUSTFLAGS=-Zsanitizer=address RUSTDOCFLAGS=-Zsanitizer=address
$ cargo run -Zbuild-std --target x86_64-unknown-linux-gnu
=================================================================
==39249==ERROR: AddressSanitizer: stack-use-after-scope on address 0x7ffc7ed3e1a0 at pc 0x55c98b262a8e bp 0x7ffc7ed3e050 sp 0x7ffc7ed3e048
WRITE of size 8 at 0x7ffc7ed3e1a0 thread T0
    #0 0x55c98b262a8d in core::ptr::write_volatile::he21f1df5a82f329a /.../src/rust/src/libcore/ptr/mod.rs:1048:5
    #1 0x55c98b262cd2 in example::main::h628ffc6626ed85b2 /.../src/main.rs:9:9
    ...

Address 0x7ffc7ed3e1a0 is located in stack of thread T0 at offset 32 in frame
    #0 0x55c98b262bdf in example::main::h628ffc6626ed85b2 /.../src/main.rs:3

  This frame has 1 object(s):
    [32, 40) 'x' (line 6) &lt;== Memory access at offset 32 is inside this variable
HINT: this may be a false positive if your program uses some custom stack unwind mechanism, swapcontext or vfork
      (longjmp and C++ exceptions *are* supported)
SUMMARY: AddressSanitizer: stack-use-after-scope /.../src/rust/src/libcore/ptr/mod.rs:1048:5 in core::ptr::write_volatile::he21f1df5a82f329a
Shadow bytes around the buggy address:
  0x10000fd9fbe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x10000fd9fbf0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x10000fd9fc00: 00 00 00 00 00 00 00 00 00 00 00 00 f1 f1 f1 f1
  0x10000fd9fc10: f8 f8 f3 f3 00 00 00 00 00 00 00 00 00 00 00 00
  0x10000fd9fc20: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
=&gt;0x10000fd9fc30: f1 f1 f1 f1[f8]f3 f3 f3 00 00 00 00 00 00 00 00
  0x10000fd9fc40: 00 00 00 00 00 00 00 00 00 00 00 00 f1 f1 f1 f1
  0x10000fd9fc50: 00 00 f3 f3 00 00 00 00 00 00 00 00 00 00 00 00
  0x10000fd9fc60: 00 00 00 00 00 00 00 00 f1 f1 f1 f1 00 00 f3 f3
  0x10000fd9fc70: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x10000fd9fc80: 00 00 00 00 f1 f1 f1 f1 00 00 f3 f3 00 00 00 00
Shadow byte legend (one shadow byte represents 8 application bytes):
  Addressable:           00
  Partially addressable: 01 02 03 04 05 06 07
  Heap left redzone:       fa
  Freed heap region:       fd
  Stack left redzone:      f1
  Stack mid redzone:       f2
  Stack right redzone:     f3
  Stack after return:      f5
  Stack use after scope:   f8
  Global redzone:          f9
  Global init order:       f6
  Poisoned by user:        f7
  Container overflow:      fc
  Array cookie:            ac
  Intra object redzone:    bb
  ASan internal:           fe
  Left alloca redzone:     ca
  Right alloca redzone:    cb
  Shadow gap:              cc
==39249==ABORTING
</code></pre>
<h1 id="controlflowintegrity"><a class="header" href="#controlflowintegrity">ControlFlowIntegrity</a></h1>
<p>The LLVM CFI support in the Rust compiler provides forward-edge control flow
protection for both Rust-compiled code only and for C or C++ and Rust -compiled
code mixed-language binaries, also known as “mixed binaries” (i.e., for when C
or C++ and Rust -compiled code share the same virtual address space), by
aggregating function pointers in groups identified by their return and parameter
types.</p>
<p>LLVM CFI can be enabled with <code>-Zsanitizer=cfi</code> and requires LTO (i.e.,
<code>-Clinker-plugin-lto</code> or <code>-Clto</code>). Cross-language LLVM CFI can be enabled with
<code>-Zsanitizer=cfi</code>, and requires the <code>-Zsanitizer-cfi-normalize-integers</code> option
to be used with Clang <code>-fsanitize-cfi-icall-experimental-normalize-integers</code>
option for cross-language LLVM CFI support, and proper (i.e., non-rustc) LTO
(i.e., <code>-Clinker-plugin-lto</code>).</p>
<p>It is recommended to rebuild the standard library with CFI enabled by using the
Cargo build-std feature (i.e., <code>-Zbuild-std</code>) when enabling CFI.</p>
<p>See the <a href="https://clang.llvm.org/docs/ControlFlowIntegrity.html">Clang ControlFlowIntegrity documentation</a> for more details.</p>
<h2 id="example-1-redirecting-control-flow-using-an-indirect-branchcall-to-an-invalid-destination"><a class="header" href="#example-1-redirecting-control-flow-using-an-indirect-branchcall-to-an-invalid-destination">Example 1: Redirecting control flow using an indirect branch/call to an invalid destination</a></h2>
<pre><code class="language-rust ignore (making doc tests pass cross-platform is hard)">#![feature(naked_functions)]

use std::arch::asm;
use std::mem;

fn add_one(x: i32) -&gt; i32 {
    x + 1
}

#[naked]
pub extern "C" fn add_two(x: i32) {
    // x + 2 preceded by a landing pad/nop block
    unsafe {
        asm!(
            "
             nop
             nop
             nop
             nop
             nop
             nop
             nop
             nop
             nop
             lea eax, [rdi+2]
             ret
        ",
            options(noreturn)
        );
    }
}

fn do_twice(f: fn(i32) -&gt; i32, arg: i32) -&gt; i32 {
    f(arg) + f(arg)
}

fn main() {
    let answer = do_twice(add_one, 5);

    println!("The answer is: {}", answer);

    println!("With CFI enabled, you should not see the next answer");
    let f: fn(i32) -&gt; i32 = unsafe {
        // Offset 0 is a valid branch/call destination (i.e., the function entry
        // point), but offsets 1-8 within the landing pad/nop block are invalid
        // branch/call destinations (i.e., within the body of the function).
        mem::transmute::&lt;*const u8, fn(i32) -&gt; i32&gt;((add_two as *const u8).offset(5))
    };
    let next_answer = do_twice(f, 5);

    println!("The next answer is: {}", next_answer);
}</code></pre>
<p>Fig. 1. Redirecting control flow using an indirect branch/call to an invalid
destination (i.e., within the body of the function).</p>
<pre><code class="language-shell">$ cargo run --release
   Compiling rust-cfi-1 v0.1.0 (/home/rcvalle/rust-cfi-1)
    Finished release [optimized] target(s) in 0.42s
     Running `target/release/rust-cfi-1`
The answer is: 12
With CFI enabled, you should not see the next answer
The next answer is: 14
$
</code></pre>
<p>Fig. 2. Build and execution of Fig. 1 with LLVM CFI disabled.</p>
<pre><code class="language-shell">$ RUSTFLAGS="-Clinker-plugin-lto -Clinker=clang -Clink-arg=-fuse-ld=lld -Zsanitizer=cfi" cargo run -Zbuild-std -Zbuild-std-features --release --target x86_64-unknown-linux-gnu
   ...
   Compiling rust-cfi-1 v0.1.0 (/home/rcvalle/rust-cfi-1)
    Finished release [optimized] target(s) in 1m 08s
     Running `target/x86_64-unknown-linux-gnu/release/rust-cfi-1`
The answer is: 12
With CFI enabled, you should not see the next answer
Illegal instruction
$
</code></pre>
<p>Fig. 3. Build and execution of Fig. 1 with LLVM CFI enabled.</p>
<p>When LLVM CFI is enabled, if there are any attempts to change/hijack control
flow using an indirect branch/call to an invalid destination, the execution is
terminated (see Fig. 3).</p>
<h2 id="example-2-redirecting-control-flow-using-an-indirect-branchcall-to-a-function-with-a-different-number-of-parameters"><a class="header" href="#example-2-redirecting-control-flow-using-an-indirect-branchcall-to-a-function-with-a-different-number-of-parameters">Example 2: Redirecting control flow using an indirect branch/call to a function with a different number of parameters</a></h2>
<pre><pre class="playground"><code class="language-rust">use std::mem;

fn add_one(x: i32) -&gt; i32 {
    x + 1
}

fn add_two(x: i32, _y: i32) -&gt; i32 {
    x + 2
}

fn do_twice(f: fn(i32) -&gt; i32, arg: i32) -&gt; i32 {
    f(arg) + f(arg)
}

fn main() {
    let answer = do_twice(add_one, 5);

    println!("The answer is: {}", answer);

    println!("With CFI enabled, you should not see the next answer");
    let f: fn(i32) -&gt; i32 =
        unsafe { mem::transmute::&lt;*const u8, fn(i32) -&gt; i32&gt;(add_two as *const u8) };
    let next_answer = do_twice(f, 5);

    println!("The next answer is: {}", next_answer);
}</code></pre></pre>
<p>Fig. 4. Redirecting control flow using an indirect branch/call to a function
with a different number of parameters than arguments intended/passed in the
call/branch site.</p>
<pre><code class="language-shell">$ cargo run --release
   Compiling rust-cfi-2 v0.1.0 (/home/rcvalle/rust-cfi-2)
    Finished release [optimized] target(s) in 0.43s
     Running `target/release/rust-cfi-2`
The answer is: 12
With CFI enabled, you should not see the next answer
The next answer is: 14
$
</code></pre>
<p>Fig. 5. Build and execution of Fig. 4 with LLVM CFI disabled.</p>
<pre><code class="language-shell">$ RUSTFLAGS="-Clinker-plugin-lto -Clinker=clang -Clink-arg=-fuse-ld=lld -Zsanitizer=cfi" cargo run -Zbuild-std -Zbuild-std-features --release --target x86_64-unknown-linux-gnu
   ...
   Compiling rust-cfi-2 v0.1.0 (/home/rcvalle/rust-cfi-2)
    Finished release [optimized] target(s) in 1m 08s
     Running `target/x86_64-unknown-linux-gnu/release/rust-cfi-2`
The answer is: 12
With CFI enabled, you should not see the next answer
Illegal instruction
$
</code></pre>
<p>Fig. 6. Build and execution of Fig. 4 with LLVM CFI enabled.</p>
<p>When LLVM CFI is enabled, if there are any attempts to change/hijack control
flow using an indirect branch/call to a function with different number of
parameters than arguments intended/passed in the call/branch site, the
execution is also terminated (see Fig. 6).</p>
<h2 id="example-3-redirecting-control-flow-using-an-indirect-branchcall-to-a-function-with-different-return-and-parameter-types"><a class="header" href="#example-3-redirecting-control-flow-using-an-indirect-branchcall-to-a-function-with-different-return-and-parameter-types">Example 3: Redirecting control flow using an indirect branch/call to a function with different return and parameter types</a></h2>
<pre><pre class="playground"><code class="language-rust">use std::mem;

fn add_one(x: i32) -&gt; i32 {
    x + 1
}

fn add_two(x: i64) -&gt; i64 {
    x + 2
}

fn do_twice(f: fn(i32) -&gt; i32, arg: i32) -&gt; i32 {
    f(arg) + f(arg)
}

fn main() {
    let answer = do_twice(add_one, 5);

    println!("The answer is: {}", answer);

    println!("With CFI enabled, you should not see the next answer");
    let f: fn(i32) -&gt; i32 =
        unsafe { mem::transmute::&lt;*const u8, fn(i32) -&gt; i32&gt;(add_two as *const u8) };
    let next_answer = do_twice(f, 5);

    println!("The next answer is: {}", next_answer);
}</code></pre></pre>
<p>Fig. 7. Redirecting control flow using an indirect branch/call to a function
with different return and parameter types than the return type expected and
arguments intended/passed at the call/branch site.</p>
<pre><code class="language-shell">$ cargo run --release
   Compiling rust-cfi-3 v0.1.0 (/home/rcvalle/rust-cfi-3)
    Finished release [optimized] target(s) in 0.44s
     Running `target/release/rust-cfi-3`
The answer is: 12
With CFI enabled, you should not see the next answer
The next answer is: 14
$
</code></pre>
<p>Fig. 8. Build and execution of Fig. 7 with LLVM CFI disabled.</p>
<pre><code class="language-shell">$ RUSTFLAGS="-Clinker-plugin-lto -Clinker=clang -Clink-arg=-fuse-ld=lld -Zsanitizer=cfi" cargo run -Zbuild-std -Zbuild-std-features --release --target x86_64-unknown-linux-gnu
   ...
   Compiling rust-cfi-3 v0.1.0 (/home/rcvalle/rust-cfi-3)
    Finished release [optimized] target(s) in 1m 07s
     Running `target/x86_64-unknown-linux-gnu/release/rust-cfi-3`
The answer is: 12
With CFI enabled, you should not see the next answer
Illegal instruction
$
</code></pre>
<p>Fig. 9. Build and execution of Fig. 7 with LLVM CFI enabled.</p>
<p>When LLVM CFI is enabled, if there are any attempts to change/hijack control
flow using an indirect branch/call to a function with different return and
parameter types than the return type expected and arguments intended/passed in
the call/branch site, the execution is also terminated (see Fig. 9).</p>
<h2 id="example-4-redirecting-control-flow-using-an-indirect-branchcall-to-a-function-with-different-return-and-parameter-types-across-the-ffi-boundary"><a class="header" href="#example-4-redirecting-control-flow-using-an-indirect-branchcall-to-a-function-with-different-return-and-parameter-types-across-the-ffi-boundary">Example 4: Redirecting control flow using an indirect branch/call to a function with different return and parameter types across the FFI boundary</a></h2>
<pre><code class="language-ignore (cannot-test-this-because-uses-custom-build)">int
do_twice(int (*fn)(int), int arg)
{
    return fn(arg) + fn(arg);
}
</code></pre>
<p>Fig. 10. Example C library.</p>
<pre><code class="language-ignore (cannot-test-this-because-uses-custom-build)">use std::mem;

#[link(name = "foo")]
extern "C" {
    fn do_twice(f: unsafe extern "C" fn(i32) -&gt; i32, arg: i32) -&gt; i32;
}

unsafe extern "C" fn add_one(x: i32) -&gt; i32 {
    x + 1
}

unsafe extern "C" fn add_two(x: i64) -&gt; i64 {
    x + 2
}

fn main() {
    let answer = unsafe { do_twice(add_one, 5) };

    println!("The answer is: {}", answer);

    println!("With CFI enabled, you should not see the next answer");
    let f: unsafe extern "C" fn(i32) -&gt; i32 = unsafe {
        mem::transmute::&lt;*const u8, unsafe extern "C" fn(i32) -&gt; i32&gt;(add_two as *const u8)
    };
    let next_answer = unsafe { do_twice(f, 5) };

    println!("The next answer is: {}", next_answer);
}
</code></pre>
<p>Fig. 11. Redirecting control flow using an indirect branch/call to a function
with different return and parameter types than the return type expected and
arguments intended/passed in the call/branch site, across the FFI boundary.</p>
<pre><code class="language-shell">$ make
mkdir -p target/release
clang -I. -Isrc -Wall -c src/foo.c -o target/release/libfoo.o
llvm-ar rcs target/release/libfoo.a target/release/libfoo.o
RUSTFLAGS="-L./target/release -Clinker=clang -Clink-arg=-fuse-ld=lld" cargo build --release
   Compiling rust-cfi-4 v0.1.0 (/home/rcvalle/rust-cfi-4)
    Finished release [optimized] target(s) in 0.49s
$ ./target/release/rust-cfi-4
The answer is: 12
With CFI enabled, you should not see the next answer
The next answer is: 14
$
</code></pre>
<p>Fig. 12. Build and execution of Figs. 10–11 with LLVM CFI disabled.</p>
<pre><code class="language-shell">$ make
mkdir -p target/release
clang -I. -Isrc -Wall -flto -fsanitize=cfi -fsanitize-cfi-icall-experimental-normalize-integers -fvisibility=hidden -c -emit-llvm src/foo.c -o target/release/libfoo.bc
llvm-ar rcs target/release/libfoo.a target/release/libfoo.bc
RUSTFLAGS="-L./target/release -Clinker-plugin-lto -Clinker=clang -Clink-arg=-fuse-ld=lld -Zsanitizer=cfi -Zsanitizer-cfi-normalize-integers" cargo build -Zbuild-std -Zbuild-std-features --release --target x86_64-unknown-linux-gnu
   ...
   Compiling rust-cfi-4 v0.1.0 (/home/rcvalle/rust-cfi-4)
    Finished release [optimized] target(s) in 1m 06s
$ ./target/x86_64-unknown-linux-gnu/release/rust-cfi-4
The answer is: 12
With CFI enabled, you should not see the next answer
Illegal instruction
$
</code></pre>
<p>Fig. 13. Build and execution of FIgs. 10–11 with LLVM CFI enabled.</p>
<p>When LLVM CFI is enabled, if there are any attempts to redirect control flow
using an indirect branch/call to a function with different return and parameter
types than the return type expected and arguments intended/passed in the
call/branch site, even across the FFI boundary and for extern "C" function types
indirectly called (i.e., callbacks/function pointers) across the FFI boundary,
the execution is also terminated (see Fig. 13).</p>
<h1 id="hwaddresssanitizer"><a class="header" href="#hwaddresssanitizer">HWAddressSanitizer</a></h1>
<p>HWAddressSanitizer is a newer variant of AddressSanitizer that consumes much
less memory.</p>
<p>HWAddressSanitizer is supported on the following targets:</p>
<ul>
<li><code>aarch64-linux-android</code></li>
<li><code>aarch64-unknown-linux-gnu</code></li>
</ul>
<p>HWAddressSanitizer requires <code>tagged-globals</code> target feature to instrument
globals. To enable this target feature compile with <code>-C target-feature=+tagged-globals</code></p>
<p>See the <a href="https://clang.llvm.org/docs/HardwareAssistedAddressSanitizerDesign.html">Clang HWAddressSanitizer documentation</a> for more details.</p>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<p>Heap buffer overflow:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let xs = vec![0, 1, 2, 3];
    let _y = unsafe { *xs.as_ptr().offset(4) };
}</code></pre></pre>
<pre><code class="language-shell">$ rustc main.rs -Zsanitizer=hwaddress -C target-feature=+tagged-globals -C
linker=aarch64-linux-gnu-gcc -C link-arg=-fuse-ld=lld --target
aarch64-unknown-linux-gnu
</code></pre>
<pre><code class="language-shell">$ ./main
==241==ERROR: HWAddressSanitizer: tag-mismatch on address 0xefdeffff0050 at pc 0xaaaae0ae4a98
READ of size 4 at 0xefdeffff0050 tags: 2c/00 (ptr/mem) in thread T0
    #0 0xaaaae0ae4a94  (/.../main+0x54a94)
    ...

[0xefdeffff0040,0xefdeffff0060) is a small allocated heap chunk; size: 32 offset: 16
0xefdeffff0050 is located 0 bytes to the right of 16-byte region [0xefdeffff0040,0xefdeffff0050)
allocated here:
    #0 0xaaaae0acb80c  (/.../main+0x3b80c)
    ...

Thread: T0 0xeffe00002000 stack: [0xffffc28ad000,0xffffc30ad000) sz: 8388608 tls: [0xffffaa10a020,0xffffaa10a7d0)
Memory tags around the buggy address (one tag corresponds to 16 bytes):
  0xfefcefffef80: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00
  0xfefcefffef90: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00
  0xfefcefffefa0: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00
  0xfefcefffefb0: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00
  0xfefcefffefc0: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00
  0xfefcefffefd0: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00
  0xfefcefffefe0: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00
  0xfefcefffeff0: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00
=&gt;0xfefceffff000: d7  d7  05  00  2c [00] 00  00  00  00  00  00  00  00  00  00
  0xfefceffff010: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00
  0xfefceffff020: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00
  0xfefceffff030: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00
  0xfefceffff040: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00
  0xfefceffff050: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00
  0xfefceffff060: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00
  0xfefceffff070: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00
  0xfefceffff080: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00
Tags for short granules around the buggy address (one tag corresponds to 16 bytes):
  0xfefcefffeff0: ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..
=&gt;0xfefceffff000: ..  ..  8c  ..  .. [..] ..  ..  ..  ..  ..  ..  ..  ..  ..  ..
  0xfefceffff010: ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..
See https://clang.llvm.org/docs/HardwareAssistedAddressSanitizerDesign.html#short-granules for a description of short granule tags
Registers where the failure occurred (pc 0xaaaae0ae4a98):
    x0  2c00efdeffff0050  x1  0000000000000004  x2  0000000000000004  x3  0000000000000000
    x4  0000fffefc30ac37  x5  000000000000005d  x6  00000ffffc30ac37  x7  0000efff00000000
    x8  2c00efdeffff0050  x9  0200efff00000000  x10 0000000000000000  x11 0200efff00000000
    x12 0200effe00000310  x13 0200effe00000310  x14 0000000000000008  x15 5d00ffffc30ac360
    x16 0000aaaae0ad062c  x17 0000000000000003  x18 0000000000000001  x19 0000ffffc30ac658
    x20 4e00ffffc30ac6e0  x21 0000aaaae0ac5e10  x22 0000000000000000  x23 0000000000000000
    x24 0000000000000000  x25 0000000000000000  x26 0000000000000000  x27 0000000000000000
    x28 0000000000000000  x29 0000ffffc30ac5a0  x30 0000aaaae0ae4a98
SUMMARY: HWAddressSanitizer: tag-mismatch (/.../main+0x54a94)
</code></pre>
<h1 id="kernelcontrolflowintegrity"><a class="header" href="#kernelcontrolflowintegrity">KernelControlFlowIntegrity</a></h1>
<p>The LLVM Kernel Control Flow Integrity (CFI) support to the Rust compiler
initially provides forward-edge control flow protection for operating systems
kernels for Rust-compiled code only by aggregating function pointers in groups
identified by their return and parameter types. (See <a href="https://github.com/llvm/llvm-project/commit/cff5bef948c91e4919de8a5fb9765e0edc13f3de">LLVM commit cff5bef "KCFI
sanitizer"</a>.)</p>
<p>Forward-edge control flow protection for C or C++ and Rust -compiled code "mixed
binaries" (i.e., for when C or C++ and Rust -compiled code share the same
virtual address space) will be provided in later work by defining and using
compatible type identifiers (see Type metadata in the design document in the
tracking issue <a href="https://github.com/rust-lang/rust/issues/89653">#89653</a>).</p>
<p>LLVM KCFI can be enabled with <code>-Zsanitizer=kcfi</code>.</p>
<p>LLVM KCFI is supported on the following targets:</p>
<ul>
<li><code>aarch64-linux-android</code></li>
<li><code>aarch64-unknown-linux-gnu</code></li>
<li><code>x86_64-linux-android</code></li>
<li><code>x86_64-unknown-linux-gnu</code></li>
</ul>
<p>See the <a href="https://clang.llvm.org/docs/ControlFlowIntegrity.html#fsanitize-kcfi">Clang KernelControlFlowIntegrity documentation</a> for more
details.</p>
<h1 id="dataflowsanitizer"><a class="header" href="#dataflowsanitizer">DataFlowSanitizer</a></h1>
<p>DataFlowSanitizer is a generalised dynamic data flow analysis.</p>
<p>Unlike other Sanitizer tools, this tool is not designed to detect a specific
class of bugs on its own. Instead, it provides a generic dynamic data flow
analysis framework to be used by clients to help detect application-specific
issues within their own code.</p>
<p>DataFlowSanitizer is supported on the following targets:</p>
<ul>
<li><code>x86_64-unknown-linux-gnu</code></li>
</ul>
<p>See the <a href="https://clang.llvm.org/docs/DataFlowSanitizer.html">Clang DataFlowSanitizer documentation</a> for more details.</p>
<h1 id="kerneladdresssanitizer"><a class="header" href="#kerneladdresssanitizer">KernelAddressSanitizer</a></h1>
<p>KernelAddressSanitizer (KASAN) is a freestanding version of AddressSanitizer
which is suitable for detecting memory errors in programs which do not have a
runtime environment, such as operating system kernels. KernelAddressSanitizer
requires manual implementation of the underlying functions used for tracking
KernelAddressSanitizer state.</p>
<p>KernelAddressSanitizer is supported on the following targets:</p>
<ul>
<li><code>aarch64-unknown-none</code></li>
<li><code>riscv64gc-unknown-none-elf</code></li>
<li><code>riscv64imac-unknown-none-elf</code></li>
<li><code>x86_64-unknown-none</code></li>
</ul>
<p>See the <a href="https://www.kernel.org/doc/html/latest/dev-tools/kasan.html">Linux Kernel's KernelAddressSanitizer documentation</a> for
more details.</p>
<h1 id="leaksanitizer"><a class="header" href="#leaksanitizer">LeakSanitizer</a></h1>
<p>LeakSanitizer is run-time memory leak detector.</p>
<p>LeakSanitizer is supported on the following targets:</p>
<ul>
<li><code>aarch64-unknown-linux-gnu</code></li>
<li><code>x86_64-apple-darwin</code></li>
<li><code>x86_64-unknown-linux-gnu</code></li>
</ul>
<p>See the <a href="https://clang.llvm.org/docs/LeakSanitizer.html">Clang LeakSanitizer documentation</a> for more details.</p>
<h1 id="memorysanitizer"><a class="header" href="#memorysanitizer">MemorySanitizer</a></h1>
<p>MemorySanitizer is detector of uninitialized reads.</p>
<p>MemorySanitizer is supported on the following targets:</p>
<ul>
<li><code>aarch64-unknown-linux-gnu</code></li>
<li><code>x86_64-unknown-freebsd</code></li>
<li><code>x86_64-unknown-linux-gnu</code></li>
</ul>
<p>MemorySanitizer requires all program code to be instrumented. C/C++ dependencies
need to be recompiled using Clang with <code>-fsanitize=memory</code> option. Failing to
achieve that will result in false positive reports.</p>
<p>See the <a href="https://clang.llvm.org/docs/MemorySanitizer.html">Clang MemorySanitizer documentation</a> for more details.</p>
<h2 id="example-1"><a class="header" href="#example-1">Example</a></h2>
<p>Detecting the use of uninitialized memory. The <code>-Zbuild-std</code> flag rebuilds and
instruments the standard library, and is strictly necessary for the correct
operation of the tool. The <code>-Zsanitizer-memory-track-origins</code> enables tracking
of the origins of uninitialized memory:</p>
<pre><pre class="playground"><code class="language-rust">use std::mem::MaybeUninit;

fn main() {
    unsafe {
        let a = MaybeUninit::&lt;[usize; 4]&gt;::uninit();
        let a = a.assume_init();
        println!("{}", a[2]);
    }
}</code></pre></pre>
<pre><code class="language-shell">$ export \
  RUSTFLAGS='-Zsanitizer=memory -Zsanitizer-memory-track-origins' \
  RUSTDOCFLAGS='-Zsanitizer=memory -Zsanitizer-memory-track-origins'
$ cargo clean
$ cargo run -Zbuild-std --target x86_64-unknown-linux-gnu
==9416==WARNING: MemorySanitizer: use-of-uninitialized-value
    #0 0x560c04f7488a in core::fmt::num::imp::fmt_u64::haa293b0b098501ca $RUST/build/x86_64-unknown-linux-gnu/stage1/lib/rustlib/src/rust/src/libcore/fmt/num.rs:202:16
...
  Uninitialized value was stored to memory at
    #0 0x560c04ae898a in __msan_memcpy.part.0 $RUST/src/llvm-project/compiler-rt/lib/msan/msan_interceptors.cc:1558:3
    #1 0x560c04b2bf88 in memory::main::hd2333c1899d997f5 $CWD/src/main.rs:6:16

  Uninitialized value was created by an allocation of 'a' in the stack frame of function '_ZN6memory4main17hd2333c1899d997f5E'
    #0 0x560c04b2bc50 in memory::main::hd2333c1899d997f5 $CWD/src/main.rs:3
</code></pre>
<h1 id="memtagsanitizer"><a class="header" href="#memtagsanitizer">MemTagSanitizer</a></h1>
<p>MemTagSanitizer detects a similar class of errors as AddressSanitizer and HardwareAddressSanitizer, but with lower overhead suitable for use as hardening for production binaries.</p>
<p>MemTagSanitizer is supported on the following targets:</p>
<ul>
<li><code>aarch64-linux-android</code></li>
<li><code>aarch64-unknown-linux-gnu</code></li>
</ul>
<p>MemTagSanitizer requires hardware support and the <code>mte</code> target feature.
To enable this target feature compile with <code>-C target-feature="+mte"</code>.</p>
<p>See the <a href="https://llvm.org/docs/MemTagSanitizer.html">LLVM MemTagSanitizer documentation</a> for more details.</p>
<h1 id="safestack"><a class="header" href="#safestack">SafeStack</a></h1>
<p>SafeStack provides backward edge control flow protection by separating the stack into data which is only accessed safely (the safe stack) and all other data (the unsafe stack).</p>
<p>SafeStack can be enabled with the <code>-Zsanitizer=safestack</code> option and is supported on the following targets:</p>
<ul>
<li><code>x86_64-unknown-linux-gnu</code></li>
</ul>
<p>See the <a href="https://clang.llvm.org/docs/SafeStack.html">Clang SafeStack documentation</a> for more details.</p>
<h1 id="shadowcallstack"><a class="header" href="#shadowcallstack">ShadowCallStack</a></h1>
<p>ShadowCallStack provides backward edge control flow protection by storing a function's return address in a separately allocated 'shadow call stack'
and loading the return address from that shadow call stack.
AArch64 and RISC-V both have a platform register defined in their ABIs, which is <code>x18</code> and <code>x3</code>/<code>gp</code> respectively, that can optionally be reserved for this purpose.
Software support from the operating system and runtime may be required depending on the target platform which is detailed in the remaining section.
See the <a href="https://clang.llvm.org/docs/ShadowCallStack.html">Clang ShadowCallStack documentation</a> for more details.</p>
<p>ShadowCallStack can be enabled with <code>-Zsanitizer=shadow-call-stack</code> option and is supported on the following targets:</p>
<h2 id="aarch64-family"><a class="header" href="#aarch64-family">AArch64 family</a></h2>
<p>ShadowCallStack requires the use of the ABI defined platform register, <code>x18</code>, which is required for code generation purposes.
When <code>x18</code> is not reserved, and is instead used as a scratch register subsequently, enabling ShadowCallStack would lead to undefined behaviour
due to corruption of return address or invalid memory access when the instrumentation restores return register to the link register <code>lr</code> from the
already clobbered <code>x18</code> register.
In other words, code that is calling into or called by functions instrumented with ShadowCallStack must reserve the <code>x18</code> register or preserve its value.</p>
<h3 id="aarch64-linux-android-and-aarch64-unknown-fuchsiaaarch64-fuchsia"><a class="header" href="#aarch64-linux-android-and-aarch64-unknown-fuchsiaaarch64-fuchsia"><code>aarch64-linux-android</code> and <code>aarch64-unknown-fuchsia</code>/<code>aarch64-fuchsia</code></a></h3>
<p>This target already reserves the <code>x18</code> register.
A runtime must be provided by the application or operating system.
If <code>bionic</code> is used on this target, the software support is provided.
Otherwise, a runtime needs to prepare a memory region and points <code>x18</code> to the region which serves as the shadow call stack.</p>
<h3 id="aarch64-unknown-none"><a class="header" href="#aarch64-unknown-none"><code>aarch64-unknown-none</code></a></h3>
<p>In addition to support from a runtime by the application or operating system, the <code>-Zfixed-x18</code> flag is also mandatory.</p>
<h2 id="risc-v-64-family"><a class="header" href="#risc-v-64-family">RISC-V 64 family</a></h2>
<p>ShadowCallStack uses either the <code>gp</code> register for software shadow stack, also known as <code>x3</code>, or the <code>ssp</code> register if <a href="https://github.com/riscv/riscv-cfi/blob/3f8e450c481ac303bd5643444f7a89672f24476e/src/cfi_backward.adoc"><code>Zicfiss</code></a> extension is available.
<code>gp</code>/<code>x3</code> is currently always reserved and available for ShadowCallStack instrumentation, and <code>ssp</code> in case of <code>Zicfiss</code> is only accessible through its dedicated shadow stack instructions.</p>
<p>Support from the runtime and operating system is required when <code>gp</code>/<code>x3</code> is used for software shadow stack.
A runtime must prepare a memory region and point <code>gp</code>/<code>x3</code> to the region before executing the code.</p>
<p>The following targets support ShadowCallStack.</p>
<ul>
<li><code>riscv64imac-unknown-none-elf</code></li>
<li><code>riscv64gc-unknown-none-elf</code></li>
<li><code>riscv64gc-unknown-fuchsia</code></li>
</ul>
<h1 id="threadsanitizer"><a class="header" href="#threadsanitizer">ThreadSanitizer</a></h1>
<p>ThreadSanitizer is a data race detection tool. It is supported on the following
targets:</p>
<ul>
<li><code>aarch64-apple-darwin</code></li>
<li><code>aarch64-unknown-linux-gnu</code></li>
<li><code>x86_64-apple-darwin</code></li>
<li><code>x86_64-unknown-freebsd</code></li>
<li><code>x86_64-unknown-linux-gnu</code></li>
</ul>
<p>To work correctly ThreadSanitizer needs to be "aware" of all synchronization
operations in a program. It generally achieves that through combination of
library interception (for example synchronization performed through
<code>pthread_mutex_lock</code> / <code>pthread_mutex_unlock</code>) and compile time instrumentation
(e.g. atomic operations). Using it without instrumenting all the program code
can lead to false positive reports.</p>
<p>ThreadSanitizer does not support atomic fences <code>std::sync::atomic::fence</code>,
nor synchronization performed using inline assembly code.</p>
<p>See the <a href="https://clang.llvm.org/docs/ThreadSanitizer.html">Clang ThreadSanitizer documentation</a> for more details.</p>
<h2 id="example-2"><a class="header" href="#example-2">Example</a></h2>
<pre><pre class="playground"><code class="language-rust">static mut A: usize = 0;

fn main() {
    let t = std::thread::spawn(|| {
        unsafe { A += 1 };
    });
    unsafe { A += 1 };

    t.join().unwrap();
}</code></pre></pre>
<pre><code class="language-shell">$ export RUSTFLAGS=-Zsanitizer=thread RUSTDOCFLAGS=-Zsanitizer=thread
$ cargo run -Zbuild-std --target x86_64-unknown-linux-gnu
==================
WARNING: ThreadSanitizer: data race (pid=10574)
  Read of size 8 at 0x5632dfe3d030 by thread T1:
    #0 example::main::_$u7b$$u7b$closure$u7d$$u7d$::h23f64b0b2f8c9484 ../src/main.rs:5:18 (example+0x86cec)
    ...

  Previous write of size 8 at 0x5632dfe3d030 by main thread:
    #0 example::main::h628ffc6626ed85b2 /.../src/main.rs:7:14 (example+0x868c8)
    ...
    #11 main &lt;null&gt; (example+0x86a1a)

  Location is global 'example::A::h43ac149ddf992709' of size 8 at 0x5632dfe3d030 (example+0x000000bd9030)
</code></pre>
<h1 id="instrumentation-of-external-dependencies-and-std"><a class="header" href="#instrumentation-of-external-dependencies-and-std">Instrumentation of external dependencies and std</a></h1>
<p>The sanitizers to varying degrees work correctly with partially instrumented
code. On the one extreme is LeakSanitizer that doesn't use any compile time
instrumentation, on the other is MemorySanitizer that requires that all program
code to be instrumented (failing to achieve that will inevitably result in
false positives).</p>
<p>It is strongly recommended to combine sanitizers with recompiled and
instrumented standard library, for example using <a href="../../cargo/reference/unstable.html#build-std">cargo <code>-Zbuild-std</code>
functionality</a>.</p>
<h1 id="working-with-other-languages"><a class="header" href="#working-with-other-languages">Working with other languages</a></h1>
<p>Sanitizers rely on compiler runtime libraries to function properly. Rust links
in its own compiler runtime which might conflict with runtimes required by
languages such as C++. Since Rust's runtime doesn't always contain the symbols
required by C++ instrumented code, you might need to skip linking it so another
runtime can be linked instead.</p>
<p>A separate unstable option <code>-Zexternal-clangrt</code> can be used to make rustc skip
linking the compiler runtime for the sanitizer. This will require you to link
in an external runtime, such as from clang instead.</p>
<h1 id="build-scripts-and-procedural-macros"><a class="header" href="#build-scripts-and-procedural-macros">Build scripts and procedural macros</a></h1>
<p>Use of sanitizers together with build scripts and procedural macros is
technically possible, but in almost all cases it would be best avoided.  This
is especially true for procedural macros which would require an instrumented
version of rustc.</p>
<p>In more practical terms when using cargo always remember to pass <code>--target</code>
flag, so that rustflags will not be applied to build scripts and procedural
macros.</p>
<h1 id="symbolizing-the-reports"><a class="header" href="#symbolizing-the-reports">Symbolizing the Reports</a></h1>
<p>Sanitizers produce symbolized stacktraces when llvm-symbolizer binary is in <code>PATH</code>.</p>
<h1 id="additional-information"><a class="header" href="#additional-information">Additional Information</a></h1>
<ul>
<li><a href="https://github.com/google/sanitizers/wiki/">Sanitizers project page</a></li>
<li><a href="https://clang.llvm.org/docs/AddressSanitizer.html">AddressSanitizer in Clang</a></li>
<li><a href="https://clang.llvm.org/docs/ControlFlowIntegrity.html">ControlFlowIntegrity in Clang</a></li>
<li><a href="https://clang.llvm.org/docs/DataFlowSanitizer.html">DataFlowSanitizer in Clang</a></li>
<li><a href="https://clang.llvm.org/docs/HardwareAssistedAddressSanitizerDesign.html">HWAddressSanitizer in Clang</a></li>
<li><a href="https://www.kernel.org/doc/html/latest/dev-tools/kasan.html">Linux Kernel's KernelAddressSanitizer documentation</a></li>
<li><a href="https://clang.llvm.org/docs/LeakSanitizer.html">LeakSanitizer in Clang</a></li>
<li><a href="https://clang.llvm.org/docs/MemorySanitizer.html">MemorySanitizer in Clang</a></li>
<li><a href="https://llvm.org/docs/MemTagSanitizer.html">MemTagSanitizer in LLVM</a></li>
<li><a href="https://clang.llvm.org/docs/ThreadSanitizer.html">ThreadSanitizer in Clang</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../compiler-flags/report-time.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../compiler-flags/self-profile.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../compiler-flags/report-time.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../compiler-flags/self-profile.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
