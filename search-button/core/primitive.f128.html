<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A 128-bit floating-point type (specifically, the “binary128” type defined in IEEE 754-2008)."><title>f128 - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-9f0942f9.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="core" data-themes="" data-resource-suffix="1.84.0" data-rustdoc-version="1.84.0-dev" data-channel="nightly" data-search-js="search-d024ca16.js" data-settings-js="settings-0f613d39.js" ><script src="../static.files/storage-0137af5f.js"></script><script defer src="sidebar-items1.84.0.js"></script><script defer src="../static.files/main-0ec32771.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc primitive"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button><a class="logo-container" href="../core/index.html"><img class="rust-logo" src="../static.files/rust-logo-9a9549ea.svg" alt=""></a></nav><nav class="sidebar"><div class="sidebar-crate"><a class="logo-container" href="../core/index.html"><img class="rust-logo" src="../static.files/rust-logo-9a9549ea.svg" alt="logo"></a><h2><a href="../core/index.html">core</a><span class="version">1.84.0-dev</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">f128</a></h2><h3><a href="#implementations">Associated Constants</a></h3><ul class="block associatedconstant"><li><a href="#associatedconstant.DIGITS" title="DIGITS">DIGITS</a></li><li><a href="#associatedconstant.EPSILON" title="EPSILON">EPSILON</a></li><li><a href="#associatedconstant.INFINITY" title="INFINITY">INFINITY</a></li><li><a href="#associatedconstant.MANTISSA_DIGITS" title="MANTISSA_DIGITS">MANTISSA_DIGITS</a></li><li><a href="#associatedconstant.MAX" title="MAX">MAX</a></li><li><a href="#associatedconstant.MAX_10_EXP" title="MAX_10_EXP">MAX_10_EXP</a></li><li><a href="#associatedconstant.MAX_EXP" title="MAX_EXP">MAX_EXP</a></li><li><a href="#associatedconstant.MIN" title="MIN">MIN</a></li><li><a href="#associatedconstant.MIN_10_EXP" title="MIN_10_EXP">MIN_10_EXP</a></li><li><a href="#associatedconstant.MIN_EXP" title="MIN_EXP">MIN_EXP</a></li><li><a href="#associatedconstant.MIN_POSITIVE" title="MIN_POSITIVE">MIN_POSITIVE</a></li><li><a href="#associatedconstant.NAN" title="NAN">NAN</a></li><li><a href="#associatedconstant.NEG_INFINITY" title="NEG_INFINITY">NEG_INFINITY</a></li><li><a href="#associatedconstant.RADIX" title="RADIX">RADIX</a></li></ul><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.abs" title="abs">abs</a></li><li><a href="#method.clamp" title="clamp">clamp</a></li><li><a href="#method.classify" title="classify">classify</a></li><li><a href="#method.copysign" title="copysign">copysign</a></li><li><a href="#method.from_be_bytes" title="from_be_bytes">from_be_bytes</a></li><li><a href="#method.from_bits" title="from_bits">from_bits</a></li><li><a href="#method.from_le_bytes" title="from_le_bytes">from_le_bytes</a></li><li><a href="#method.from_ne_bytes" title="from_ne_bytes">from_ne_bytes</a></li><li><a href="#method.is_finite" title="is_finite">is_finite</a></li><li><a href="#method.is_infinite" title="is_infinite">is_infinite</a></li><li><a href="#method.is_nan" title="is_nan">is_nan</a></li><li><a href="#method.is_normal" title="is_normal">is_normal</a></li><li><a href="#method.is_sign_negative" title="is_sign_negative">is_sign_negative</a></li><li><a href="#method.is_sign_positive" title="is_sign_positive">is_sign_positive</a></li><li><a href="#method.is_subnormal" title="is_subnormal">is_subnormal</a></li><li><a href="#method.max" title="max">max</a></li><li><a href="#method.maximum" title="maximum">maximum</a></li><li><a href="#method.midpoint" title="midpoint">midpoint</a></li><li><a href="#method.min" title="min">min</a></li><li><a href="#method.minimum" title="minimum">minimum</a></li><li><a href="#method.next_down" title="next_down">next_down</a></li><li><a href="#method.next_up" title="next_up">next_up</a></li><li><a href="#method.recip" title="recip">recip</a></li><li><a href="#method.signum" title="signum">signum</a></li><li><a href="#method.to_be_bytes" title="to_be_bytes">to_be_bytes</a></li><li><a href="#method.to_bits" title="to_bits">to_bits</a></li><li><a href="#method.to_degrees" title="to_degrees">to_degrees</a></li><li><a href="#method.to_int_unchecked" title="to_int_unchecked">to_int_unchecked</a></li><li><a href="#method.to_le_bytes" title="to_le_bytes">to_le_bytes</a></li><li><a href="#method.to_ne_bytes" title="to_ne_bytes">to_ne_bytes</a></li><li><a href="#method.to_radians" title="to_radians">to_radians</a></li><li><a href="#method.total_cmp" title="total_cmp">total_cmp</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-Add-for-f128" title="Add">Add</a></li><li><a href="#impl-Add%3C%26f128%3E-for-%26f128" title="Add&#60;&#38;f128&#62;">Add&#60;&#38;f128&#62;</a></li><li><a href="#impl-Add%3C%26f128%3E-for-f128" title="Add&#60;&#38;f128&#62;">Add&#60;&#38;f128&#62;</a></li><li><a href="#impl-Add%3Cf128%3E-for-%26f128" title="Add&#60;f128&#62;">Add&#60;f128&#62;</a></li><li><a href="#impl-AddAssign-for-f128" title="AddAssign">AddAssign</a></li><li><a href="#impl-AddAssign%3C%26f128%3E-for-f128" title="AddAssign&#60;&#38;f128&#62;">AddAssign&#60;&#38;f128&#62;</a></li><li><a href="#impl-Clone-for-f128" title="Clone">Clone</a></li><li><a href="#impl-Copy-for-f128" title="Copy">Copy</a></li><li><a href="#impl-Debug-for-f128" title="Debug">Debug</a></li><li><a href="#impl-Default-for-f128" title="Default">Default</a></li><li><a href="#impl-Div-for-f128" title="Div">Div</a></li><li><a href="#impl-Div%3C%26f128%3E-for-%26f128" title="Div&#60;&#38;f128&#62;">Div&#60;&#38;f128&#62;</a></li><li><a href="#impl-Div%3C%26f128%3E-for-f128" title="Div&#60;&#38;f128&#62;">Div&#60;&#38;f128&#62;</a></li><li><a href="#impl-Div%3Cf128%3E-for-%26f128" title="Div&#60;f128&#62;">Div&#60;f128&#62;</a></li><li><a href="#impl-DivAssign-for-f128" title="DivAssign">DivAssign</a></li><li><a href="#impl-DivAssign%3C%26f128%3E-for-f128" title="DivAssign&#60;&#38;f128&#62;">DivAssign&#60;&#38;f128&#62;</a></li><li><a href="#impl-FloatToInt%3Ci128%3E-for-f128" title="FloatToInt&#60;i128&#62;">FloatToInt&#60;i128&#62;</a></li><li><a href="#impl-FloatToInt%3Ci16%3E-for-f128" title="FloatToInt&#60;i16&#62;">FloatToInt&#60;i16&#62;</a></li><li><a href="#impl-FloatToInt%3Ci32%3E-for-f128" title="FloatToInt&#60;i32&#62;">FloatToInt&#60;i32&#62;</a></li><li><a href="#impl-FloatToInt%3Ci64%3E-for-f128" title="FloatToInt&#60;i64&#62;">FloatToInt&#60;i64&#62;</a></li><li><a href="#impl-FloatToInt%3Ci8%3E-for-f128" title="FloatToInt&#60;i8&#62;">FloatToInt&#60;i8&#62;</a></li><li><a href="#impl-FloatToInt%3Cisize%3E-for-f128" title="FloatToInt&#60;isize&#62;">FloatToInt&#60;isize&#62;</a></li><li><a href="#impl-FloatToInt%3Cu128%3E-for-f128" title="FloatToInt&#60;u128&#62;">FloatToInt&#60;u128&#62;</a></li><li><a href="#impl-FloatToInt%3Cu16%3E-for-f128" title="FloatToInt&#60;u16&#62;">FloatToInt&#60;u16&#62;</a></li><li><a href="#impl-FloatToInt%3Cu32%3E-for-f128" title="FloatToInt&#60;u32&#62;">FloatToInt&#60;u32&#62;</a></li><li><a href="#impl-FloatToInt%3Cu64%3E-for-f128" title="FloatToInt&#60;u64&#62;">FloatToInt&#60;u64&#62;</a></li><li><a href="#impl-FloatToInt%3Cu8%3E-for-f128" title="FloatToInt&#60;u8&#62;">FloatToInt&#60;u8&#62;</a></li><li><a href="#impl-FloatToInt%3Cusize%3E-for-f128" title="FloatToInt&#60;usize&#62;">FloatToInt&#60;usize&#62;</a></li><li><a href="#impl-From%3Cf16%3E-for-f128" title="From&#60;f16&#62;">From&#60;f16&#62;</a></li><li><a href="#impl-From%3Cf32%3E-for-f128" title="From&#60;f32&#62;">From&#60;f32&#62;</a></li><li><a href="#impl-From%3Cf64%3E-for-f128" title="From&#60;f64&#62;">From&#60;f64&#62;</a></li><li><a href="#impl-Mul-for-f128" title="Mul">Mul</a></li><li><a href="#impl-Mul%3C%26f128%3E-for-%26f128" title="Mul&#60;&#38;f128&#62;">Mul&#60;&#38;f128&#62;</a></li><li><a href="#impl-Mul%3C%26f128%3E-for-f128" title="Mul&#60;&#38;f128&#62;">Mul&#60;&#38;f128&#62;</a></li><li><a href="#impl-Mul%3Cf128%3E-for-%26f128" title="Mul&#60;f128&#62;">Mul&#60;f128&#62;</a></li><li><a href="#impl-MulAssign-for-f128" title="MulAssign">MulAssign</a></li><li><a href="#impl-MulAssign%3C%26f128%3E-for-f128" title="MulAssign&#60;&#38;f128&#62;">MulAssign&#60;&#38;f128&#62;</a></li><li><a href="#impl-Neg-for-%26f128" title="Neg">Neg</a></li><li><a href="#impl-Neg-for-f128" title="Neg">Neg</a></li><li><a href="#impl-PartialEq-for-f128" title="PartialEq">PartialEq</a></li><li><a href="#impl-PartialOrd-for-f128" title="PartialOrd">PartialOrd</a></li><li><a href="#impl-Rem-for-f128" title="Rem">Rem</a></li><li><a href="#impl-Rem%3C%26f128%3E-for-%26f128" title="Rem&#60;&#38;f128&#62;">Rem&#60;&#38;f128&#62;</a></li><li><a href="#impl-Rem%3C%26f128%3E-for-f128" title="Rem&#60;&#38;f128&#62;">Rem&#60;&#38;f128&#62;</a></li><li><a href="#impl-Rem%3Cf128%3E-for-%26f128" title="Rem&#60;f128&#62;">Rem&#60;f128&#62;</a></li><li><a href="#impl-RemAssign-for-f128" title="RemAssign">RemAssign</a></li><li><a href="#impl-RemAssign%3C%26f128%3E-for-f128" title="RemAssign&#60;&#38;f128&#62;">RemAssign&#60;&#38;f128&#62;</a></li><li><a href="#impl-Sub-for-f128" title="Sub">Sub</a></li><li><a href="#impl-Sub%3C%26f128%3E-for-%26f128" title="Sub&#60;&#38;f128&#62;">Sub&#60;&#38;f128&#62;</a></li><li><a href="#impl-Sub%3C%26f128%3E-for-f128" title="Sub&#60;&#38;f128&#62;">Sub&#60;&#38;f128&#62;</a></li><li><a href="#impl-Sub%3Cf128%3E-for-%26f128" title="Sub&#60;f128&#62;">Sub&#60;f128&#62;</a></li><li><a href="#impl-SubAssign-for-f128" title="SubAssign">SubAssign</a></li><li><a href="#impl-SubAssign%3C%26f128%3E-for-f128" title="SubAssign&#60;&#38;f128&#62;">SubAssign&#60;&#38;f128&#62;</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-Freeze-for-f128" title="Freeze">Freeze</a></li><li><a href="#impl-RefUnwindSafe-for-f128" title="RefUnwindSafe">RefUnwindSafe</a></li><li><a href="#impl-Send-for-f128" title="Send">Send</a></li><li><a href="#impl-Sync-for-f128" title="Sync">Sync</a></li><li><a href="#impl-Unpin-for-f128" title="Unpin">Unpin</a></li><li><a href="#impl-UnwindSafe-for-f128" title="UnwindSafe">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T" title="Any">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T" title="Borrow&#60;T&#62;">Borrow&#60;T&#62;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T" title="BorrowMut&#60;T&#62;">BorrowMut&#60;T&#62;</a></li><li><a href="#impl-CloneToUninit-for-T" title="CloneToUninit">CloneToUninit</a></li><li><a href="#impl-From%3CT%3E-for-T" title="From&#60;T&#62;">From&#60;T&#62;</a></li><li><a href="#impl-Into%3CU%3E-for-T" title="Into&#60;U&#62;">Into&#60;U&#62;</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T" title="TryFrom&#60;U&#62;">TryFrom&#60;U&#62;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T" title="TryInto&#60;U&#62;">TryInto&#60;U&#62;</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="index.html">In crate core</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><h1>Primitive Type <span class="primitive">f128</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"></span></div><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>f128</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/116909">#116909</a>)</span></div></span><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A 128-bit floating-point type (specifically, the “binary128” type defined in IEEE 754-2008).</p>
<p>This type is very similar to <a href="primitive.f32.html" title="primitive f32"><code>f32</code></a> and <a href="primitive.f64.html" title="primitive f64"><code>f64</code></a>, but has increased precision by using twice
as many bits as <code>f64</code>. Please see <a href="primitive.f32.html" title="primitive f32">the documentation for <code>f32</code></a> or <a href="https://en.wikipedia.org/wiki/Quadruple-precision_floating-point_format">Wikipedia on
quad-precision values</a> for more information.</p>
<p>Note that no platforms have hardware support for <code>f128</code> without enabling target specific features,
as for all instruction set architectures <code>f128</code> is considered an optional feature.
Only Power ISA (“PowerPC”) and RISC-V specify it, and only certain microarchitectures
actually implement it. For x86-64 and AArch64, ISA support is not even specified,
so it will always be a software implementation significantly slower than <code>f64</code>.</p>
<p><em>Note: <code>f128</code> support is incomplete. Many platforms will not be able to link math functions. On
x86 in particular, these functions do link but their results are always incorrect.</em></p>
<p><em><a href="f128/consts/index.html" title="mod core::f128::consts">See also the <code>std::f128::consts</code> module</a>.</em></p>
</div></details><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-f128" class="impl"><a class="src rightside" href="../src/core/num/f128.rs.html#142-1369">Source</a><a href="#impl-f128" class="anchor">§</a><h3 class="code-header">impl <a class="primitive" href="primitive.f128.html">f128</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedconstant.RADIX" class="associatedconstant"><a class="src rightside" href="../src/core/num/f128.rs.html#148">Source</a><h4 class="code-header">pub const <a href="#associatedconstant.RADIX" class="constant">RADIX</a>: <a class="primitive" href="primitive.u32.html">u32</a> = 2u32</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>f128</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/116909">#116909</a>)</span></div></span></summary><div class="docblock"><p>The radix or base of the internal representation of <code>f128</code>.</p>
</div></details><details class="toggle" open><summary><section id="associatedconstant.MANTISSA_DIGITS" class="associatedconstant"><a class="src rightside" href="../src/core/num/f128.rs.html#152">Source</a><h4 class="code-header">pub const <a href="#associatedconstant.MANTISSA_DIGITS" class="constant">MANTISSA_DIGITS</a>: <a class="primitive" href="primitive.u32.html">u32</a> = 113u32</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>f128</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/116909">#116909</a>)</span></div></span></summary><div class="docblock"><p>Number of significant digits in base 2.</p>
</div></details><details class="toggle" open><summary><section id="associatedconstant.DIGITS" class="associatedconstant"><a class="src rightside" href="../src/core/num/f128.rs.html#163">Source</a><h4 class="code-header">pub const <a href="#associatedconstant.DIGITS" class="constant">DIGITS</a>: <a class="primitive" href="primitive.u32.html">u32</a> = 33u32</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>f128</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/116909">#116909</a>)</span></div></span></summary><div class="docblock"><p>Approximate number of significant digits in base 10.</p>
<p>This is the maximum <i>x</i> such that any decimal number with <i>x</i>
significant digits can be converted to <code>f128</code> and back without loss.</p>
<p>Equal to floor(log<sub>10</sub> 2<sup><a href="primitive.f128.html#associatedconstant.MANTISSA_DIGITS" title="associated constant f128::MANTISSA_DIGITS"><code>MANTISSA_DIGITS</code></a> − 1</sup>).</p>
</div></details><details class="toggle" open><summary><section id="associatedconstant.EPSILON" class="associatedconstant"><a class="src rightside" href="../src/core/num/f128.rs.html#174">Source</a><h4 class="code-header">pub const <a href="#associatedconstant.EPSILON" class="constant">EPSILON</a>: <a class="primitive" href="primitive.f128.html">f128</a> = 1.92592994438723585305597794258492732E-34f128</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>f128</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/116909">#116909</a>)</span></div></span></summary><div class="docblock"><p><a href="https://en.wikipedia.org/wiki/Machine_epsilon">Machine epsilon</a> value for <code>f128</code>.</p>
<p>This is the difference between <code>1.0</code> and the next larger representable number.</p>
<p>Equal to 2<sup>1 − <a href="primitive.f128.html#associatedconstant.MANTISSA_DIGITS" title="associated constant f128::MANTISSA_DIGITS"><code>MANTISSA_DIGITS</code></a></sup>.</p>
</div></details><details class="toggle" open><summary><section id="associatedconstant.MIN" class="associatedconstant"><a class="src rightside" href="../src/core/num/f128.rs.html#182">Source</a><h4 class="code-header">pub const <a href="#associatedconstant.MIN" class="constant">MIN</a>: <a class="primitive" href="primitive.f128.html">f128</a> = -1.18973149535723176508575932662800702E+4932f128</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>f128</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/116909">#116909</a>)</span></div></span></summary><div class="docblock"><p>Smallest finite <code>f128</code> value.</p>
<p>Equal to −<a href="primitive.f128.html#associatedconstant.MAX" title="associated constant f128::MAX"><code>MAX</code></a>.</p>
</div></details><details class="toggle" open><summary><section id="associatedconstant.MIN_POSITIVE" class="associatedconstant"><a class="src rightside" href="../src/core/num/f128.rs.html#189">Source</a><h4 class="code-header">pub const <a href="#associatedconstant.MIN_POSITIVE" class="constant">MIN_POSITIVE</a>: <a class="primitive" href="primitive.f128.html">f128</a> = 3.3621031431120935062626778173217526E-4932f128</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>f128</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/116909">#116909</a>)</span></div></span></summary><div class="docblock"><p>Smallest positive normal <code>f128</code> value.</p>
<p>Equal to 2<sup><a href="primitive.f128.html#associatedconstant.MIN_EXP" title="associated constant f128::MIN_EXP"><code>MIN_EXP</code></a> − 1</sup>.</p>
</div></details><details class="toggle" open><summary><section id="associatedconstant.MAX" class="associatedconstant"><a class="src rightside" href="../src/core/num/f128.rs.html#198">Source</a><h4 class="code-header">pub const <a href="#associatedconstant.MAX" class="constant">MAX</a>: <a class="primitive" href="primitive.f128.html">f128</a> = 1.18973149535723176508575932662800702E+4932f128</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>f128</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/116909">#116909</a>)</span></div></span></summary><div class="docblock"><p>Largest finite <code>f128</code> value.</p>
<p>Equal to
(1 − 2<sup>−<a href="primitive.f128.html#associatedconstant.MANTISSA_DIGITS" title="associated constant f128::MANTISSA_DIGITS"><code>MANTISSA_DIGITS</code></a></sup>) 2<sup><a href="primitive.f128.html#associatedconstant.MAX_EXP" title="associated constant f128::MAX_EXP"><code>MAX_EXP</code></a></sup>.</p>
</div></details><details class="toggle" open><summary><section id="associatedconstant.MIN_EXP" class="associatedconstant"><a class="src rightside" href="../src/core/num/f128.rs.html#205">Source</a><h4 class="code-header">pub const <a href="#associatedconstant.MIN_EXP" class="constant">MIN_EXP</a>: <a class="primitive" href="primitive.i32.html">i32</a> = -16_381i32</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>f128</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/116909">#116909</a>)</span></div></span></summary><div class="docblock"><p>One greater than the minimum possible normal power of 2 exponent.</p>
<p>If <i>x</i> = <code>MIN_EXP</code>, then normal numbers
≥ 0.5 × 2<sup><i>x</i></sup>.</p>
</div></details><details class="toggle" open><summary><section id="associatedconstant.MAX_EXP" class="associatedconstant"><a class="src rightside" href="../src/core/num/f128.rs.html#211">Source</a><h4 class="code-header">pub const <a href="#associatedconstant.MAX_EXP" class="constant">MAX_EXP</a>: <a class="primitive" href="primitive.i32.html">i32</a> = 16_384i32</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>f128</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/116909">#116909</a>)</span></div></span></summary><div class="docblock"><p>Maximum possible power of 2 exponent.</p>
<p>If <i>x</i> = <code>MAX_EXP</code>, then normal numbers
&lt; 1 × 2<sup><i>x</i></sup>.</p>
</div></details><details class="toggle" open><summary><section id="associatedconstant.MIN_10_EXP" class="associatedconstant"><a class="src rightside" href="../src/core/num/f128.rs.html#219">Source</a><h4 class="code-header">pub const <a href="#associatedconstant.MIN_10_EXP" class="constant">MIN_10_EXP</a>: <a class="primitive" href="primitive.i32.html">i32</a> = -4_931i32</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>f128</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/116909">#116909</a>)</span></div></span></summary><div class="docblock"><p>Minimum <i>x</i> for which 10<sup><i>x</i></sup> is normal.</p>
<p>Equal to ceil(log<sub>10</sub> <a href="primitive.f128.html#associatedconstant.MIN_POSITIVE" title="associated constant f128::MIN_POSITIVE"><code>MIN_POSITIVE</code></a>).</p>
</div></details><details class="toggle" open><summary><section id="associatedconstant.MAX_10_EXP" class="associatedconstant"><a class="src rightside" href="../src/core/num/f128.rs.html#226">Source</a><h4 class="code-header">pub const <a href="#associatedconstant.MAX_10_EXP" class="constant">MAX_10_EXP</a>: <a class="primitive" href="primitive.i32.html">i32</a> = 4_932i32</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>f128</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/116909">#116909</a>)</span></div></span></summary><div class="docblock"><p>Maximum <i>x</i> for which 10<sup><i>x</i></sup> is normal.</p>
<p>Equal to floor(log<sub>10</sub> <a href="primitive.f128.html#associatedconstant.MAX" title="associated constant f128::MAX"><code>MAX</code></a>).</p>
</div></details><details class="toggle" open><summary><section id="associatedconstant.NAN" class="associatedconstant"><a class="src rightside" href="../src/core/num/f128.rs.html#241">Source</a><h4 class="code-header">pub const <a href="#associatedconstant.NAN" class="constant">NAN</a>: <a class="primitive" href="primitive.f128.html">f128</a> = NaN_f128</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>f128</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/116909">#116909</a>)</span></div></span></summary><div class="docblock"><p>Not a Number (NaN).</p>
<p>Note that IEEE 754 doesn’t define just a single NaN value;
a plethora of bit patterns are considered to be NaN.
Furthermore, the standard makes a difference
between a “signaling” and a “quiet” NaN,
and allows inspecting its “payload” (the unspecified bits in the bit pattern).
This constant isn’t guaranteed to equal to any specific NaN bitpattern,
and the stability of its representation over Rust versions
and target platforms isn’t guaranteed.</p>
</div></details><details class="toggle" open><summary><section id="associatedconstant.INFINITY" class="associatedconstant"><a class="src rightside" href="../src/core/num/f128.rs.html#245">Source</a><h4 class="code-header">pub const <a href="#associatedconstant.INFINITY" class="constant">INFINITY</a>: <a class="primitive" href="primitive.f128.html">f128</a> = +Inf_f128</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>f128</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/116909">#116909</a>)</span></div></span></summary><div class="docblock"><p>Infinity (∞).</p>
</div></details><details class="toggle" open><summary><section id="associatedconstant.NEG_INFINITY" class="associatedconstant"><a class="src rightside" href="../src/core/num/f128.rs.html#249">Source</a><h4 class="code-header">pub const <a href="#associatedconstant.NEG_INFINITY" class="constant">NEG_INFINITY</a>: <a class="primitive" href="primitive.f128.html">f128</a> = -Inf_f128</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>f128</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/116909">#116909</a>)</span></div></span></summary><div class="docblock"><p>Negative infinity (−∞).</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_nan" class="method"><a class="src rightside" href="../src/core/num/f128.rs.html#284-286">Source</a><h4 class="code-header">pub const fn <a href="#method.is_nan" class="fn">is_nan</a>(self) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>f128</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/116909">#116909</a>)</span></div></span></summary><div class="docblock"><p>Returns <code>true</code> if this value is NaN.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(f128)]

</span><span class="kw">let </span>nan = f128::NAN;
<span class="kw">let </span>f = <span class="number">7.0_f128</span>;

<span class="macro">assert!</span>(nan.is_nan());
<span class="macro">assert!</span>(!f.is_nan());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(f128)%5D%0A//+FIXME(f16_f128):+remove+when+%60unordtf2%60+is+available%0Afn+main()+%7B%0A++++%23%5Bcfg(all(target_arch+=+%22x86_64%22,+target_os+=+%22linux%22))%5D+%7B%0A++++%0A++++let+nan+=+f128::NAN;%0A++++let+f+=+7.0_f128;%0A++++%0A++++assert!(nan.is_nan());%0A++++assert!(!f.is_nan());%0A++++%7D%0A%7D&amp;version=nightly&amp;edition=2021"></a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_infinite" class="method"><a class="src rightside" href="../src/core/num/f128.rs.html#311-313">Source</a><h4 class="code-header">pub const fn <a href="#method.is_infinite" class="fn">is_infinite</a>(self) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>f128</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/116909">#116909</a>)</span></div></span></summary><div class="docblock"><p>Returns <code>true</code> if this value is positive infinity or negative infinity, and
<code>false</code> otherwise.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(f128)]

</span><span class="kw">let </span>f = <span class="number">7.0f128</span>;
<span class="kw">let </span>inf = f128::INFINITY;
<span class="kw">let </span>neg_inf = f128::NEG_INFINITY;
<span class="kw">let </span>nan = f128::NAN;

<span class="macro">assert!</span>(!f.is_infinite());
<span class="macro">assert!</span>(!nan.is_infinite());

<span class="macro">assert!</span>(inf.is_infinite());
<span class="macro">assert!</span>(neg_inf.is_infinite());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(f128)%5D%0A//+FIXME(f16_f128):+remove+when+%60eqtf2%60+is+available%0Afn+main()+%7B%0A++++%23%5Bcfg(all(target_arch+=+%22x86_64%22,+target_os+=+%22linux%22))%5D+%7B%0A++++%0A++++let+f+=+7.0f128;%0A++++let+inf+=+f128::INFINITY;%0A++++let+neg_inf+=+f128::NEG_INFINITY;%0A++++let+nan+=+f128::NAN;%0A++++%0A++++assert!(!f.is_infinite());%0A++++assert!(!nan.is_infinite());%0A++++%0A++++assert!(inf.is_infinite());%0A++++assert!(neg_inf.is_infinite());%0A++++%7D%0A%7D&amp;version=nightly&amp;edition=2021"></a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_finite" class="method"><a class="src rightside" href="../src/core/num/f128.rs.html#338-342">Source</a><h4 class="code-header">pub const fn <a href="#method.is_finite" class="fn">is_finite</a>(self) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>f128</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/116909">#116909</a>)</span></div></span></summary><div class="docblock"><p>Returns <code>true</code> if this number is neither infinite nor NaN.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(f128)]

</span><span class="kw">let </span>f = <span class="number">7.0f128</span>;
<span class="kw">let </span>inf: f128 = f128::INFINITY;
<span class="kw">let </span>neg_inf: f128 = f128::NEG_INFINITY;
<span class="kw">let </span>nan: f128 = f128::NAN;

<span class="macro">assert!</span>(f.is_finite());

<span class="macro">assert!</span>(!nan.is_finite());
<span class="macro">assert!</span>(!inf.is_finite());
<span class="macro">assert!</span>(!neg_inf.is_finite());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(f128)%5D%0A//+FIXME(f16_f128):+remove+when+%60lttf2%60+is+available%0Afn+main()+%7B%0A++++%23%5Bcfg(all(target_arch+=+%22x86_64%22,+target_os+=+%22linux%22))%5D+%7B%0A++++%0A++++let+f+=+7.0f128;%0A++++let+inf:+f128+=+f128::INFINITY;%0A++++let+neg_inf:+f128+=+f128::NEG_INFINITY;%0A++++let+nan:+f128+=+f128::NAN;%0A++++%0A++++assert!(f.is_finite());%0A++++%0A++++assert!(!nan.is_finite());%0A++++assert!(!inf.is_finite());%0A++++assert!(!neg_inf.is_finite());%0A++++%7D%0A%7D&amp;version=nightly&amp;edition=2021"></a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_subnormal" class="method"><a class="src rightside" href="../src/core/num/f128.rs.html#371-373">Source</a><h4 class="code-header">pub const fn <a href="#method.is_subnormal" class="fn">is_subnormal</a>(self) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>f128</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/116909">#116909</a>)</span></div></span></summary><div class="docblock"><p>Returns <code>true</code> if the number is <a href="https://en.wikipedia.org/wiki/Denormal_number">subnormal</a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(f128)]

</span><span class="kw">let </span>min = f128::MIN_POSITIVE; <span class="comment">// 3.362103143e-4932f128
</span><span class="kw">let </span>max = f128::MAX;
<span class="kw">let </span>lower_than_min = <span class="number">1.0e-4960_f128</span>;
<span class="kw">let </span>zero = <span class="number">0.0_f128</span>;

<span class="macro">assert!</span>(!min.is_subnormal());
<span class="macro">assert!</span>(!max.is_subnormal());

<span class="macro">assert!</span>(!zero.is_subnormal());
<span class="macro">assert!</span>(!f128::NAN.is_subnormal());
<span class="macro">assert!</span>(!f128::INFINITY.is_subnormal());
<span class="comment">// Values between `0` and `min` are Subnormal.
</span><span class="macro">assert!</span>(lower_than_min.is_subnormal());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(f128)%5D%0A//+FIXME(f16_f128):+remove+when+%60eqtf2%60+is+available%0Afn+main()+%7B%0A++++%23%5Bcfg(all(target_arch+=+%22x86_64%22,+target_os+=+%22linux%22))%5D+%7B%0A++++%0A++++let+min+=+f128::MIN_POSITIVE;+//+3.362103143e-4932f128%0A++++let+max+=+f128::MAX;%0A++++let+lower_than_min+=+1.0e-4960_f128;%0A++++let+zero+=+0.0_f128;%0A++++%0A++++assert!(!min.is_subnormal());%0A++++assert!(!max.is_subnormal());%0A++++%0A++++assert!(!zero.is_subnormal());%0A++++assert!(!f128::NAN.is_subnormal());%0A++++assert!(!f128::INFINITY.is_subnormal());%0A++++//+Values+between+%600%60+and+%60min%60+are+Subnormal.%0A++++assert!(lower_than_min.is_subnormal());%0A++++%7D%0A%7D&amp;version=nightly&amp;edition=2021"></a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_normal" class="method"><a class="src rightside" href="../src/core/num/f128.rs.html#402-404">Source</a><h4 class="code-header">pub const fn <a href="#method.is_normal" class="fn">is_normal</a>(self) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>f128</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/116909">#116909</a>)</span></div></span></summary><div class="docblock"><p>Returns <code>true</code> if the number is neither zero, infinite, <a href="https://en.wikipedia.org/wiki/Denormal_number">subnormal</a>, or NaN.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(f128)]

</span><span class="kw">let </span>min = f128::MIN_POSITIVE; <span class="comment">// 3.362103143e-4932f128
</span><span class="kw">let </span>max = f128::MAX;
<span class="kw">let </span>lower_than_min = <span class="number">1.0e-4960_f128</span>;
<span class="kw">let </span>zero = <span class="number">0.0_f128</span>;

<span class="macro">assert!</span>(min.is_normal());
<span class="macro">assert!</span>(max.is_normal());

<span class="macro">assert!</span>(!zero.is_normal());
<span class="macro">assert!</span>(!f128::NAN.is_normal());
<span class="macro">assert!</span>(!f128::INFINITY.is_normal());
<span class="comment">// Values between `0` and `min` are Subnormal.
</span><span class="macro">assert!</span>(!lower_than_min.is_normal());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(f128)%5D%0A//+FIXME(f16_f128):+remove+when+%60eqtf2%60+is+available%0Afn+main()+%7B%0A++++%23%5Bcfg(all(target_arch+=+%22x86_64%22,+target_os+=+%22linux%22))%5D+%7B%0A++++%0A++++let+min+=+f128::MIN_POSITIVE;+//+3.362103143e-4932f128%0A++++let+max+=+f128::MAX;%0A++++let+lower_than_min+=+1.0e-4960_f128;%0A++++let+zero+=+0.0_f128;%0A++++%0A++++assert!(min.is_normal());%0A++++assert!(max.is_normal());%0A++++%0A++++assert!(!zero.is_normal());%0A++++assert!(!f128::NAN.is_normal());%0A++++assert!(!f128::INFINITY.is_normal());%0A++++//+Values+between+%600%60+and+%60min%60+are+Subnormal.%0A++++assert!(!lower_than_min.is_normal());%0A++++%7D%0A%7D&amp;version=nightly&amp;edition=2021"></a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.classify" class="method"><a class="src rightside" href="../src/core/num/f128.rs.html#426-435">Source</a><h4 class="code-header">pub const fn <a href="#method.classify" class="fn">classify</a>(self) -&gt; <a class="enum" href="num/enum.FpCategory.html" title="enum core::num::FpCategory">FpCategory</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>f128</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/116909">#116909</a>)</span></div></span></summary><div class="docblock"><p>Returns the floating point category of the number. If only one property
is going to be tested, it is generally faster to use the specific
predicate instead.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(f128)]

</span><span class="kw">use </span>std::num::FpCategory;

<span class="kw">let </span>num = <span class="number">12.4_f128</span>;
<span class="kw">let </span>inf = f128::INFINITY;

<span class="macro">assert_eq!</span>(num.classify(), FpCategory::Normal);
<span class="macro">assert_eq!</span>(inf.classify(), FpCategory::Infinite);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(f128)%5D%0A//+FIXME(f16_f128):+remove+when+%60eqtf2%60+is+available%0Afn+main()+%7B%0A++++%23%5Bcfg(all(target_arch+=+%22x86_64%22,+target_os+=+%22linux%22))%5D+%7B%0A++++%0A++++use+std::num::FpCategory;%0A++++%0A++++let+num+=+12.4_f128;%0A++++let+inf+=+f128::INFINITY;%0A++++%0A++++assert_eq!(num.classify(),+FpCategory::Normal);%0A++++assert_eq!(inf.classify(),+FpCategory::Infinite);%0A++++%7D%0A%7D&amp;version=nightly&amp;edition=2021"></a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_sign_positive" class="method"><a class="src rightside" href="../src/core/num/f128.rs.html#459-461">Source</a><h4 class="code-header">pub const fn <a href="#method.is_sign_positive" class="fn">is_sign_positive</a>(self) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>f128</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/116909">#116909</a>)</span></div></span></summary><div class="docblock"><p>Returns <code>true</code> if <code>self</code> has a positive sign, including <code>+0.0</code>, NaNs with
positive sign bit and positive infinity.</p>
<p>Note that IEEE 754 doesn’t assign any meaning to the sign bit in case of
a NaN, and as Rust doesn’t guarantee that the bit pattern of NaNs are
conserved over arithmetic operations, the result of <code>is_sign_positive</code> on
a NaN might produce an unexpected or non-portable result. See the <a href="primitive.f32.html#nan-bit-patterns" title="primitive f32">specification
of NaN bit patterns</a> for more info. Use <code>self.signum() == 1.0</code>
if you need fully portable behavior (will return <code>false</code> for all NaNs).</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(f128)]

</span><span class="kw">let </span>f = <span class="number">7.0_f128</span>;
<span class="kw">let </span>g = -<span class="number">7.0_f128</span>;

<span class="macro">assert!</span>(f.is_sign_positive());
<span class="macro">assert!</span>(!g.is_sign_positive());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(f128)%5D%0A%0Afn+main()+%7B%0A++++let+f+=+7.0_f128;%0A++++let+g+=+-7.0_f128;%0A++++%0A++++assert!(f.is_sign_positive());%0A++++assert!(!g.is_sign_positive());%0A%7D&amp;version=nightly&amp;edition=2021"></a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_sign_negative" class="method"><a class="src rightside" href="../src/core/num/f128.rs.html#485-490">Source</a><h4 class="code-header">pub const fn <a href="#method.is_sign_negative" class="fn">is_sign_negative</a>(self) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>f128</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/116909">#116909</a>)</span></div></span></summary><div class="docblock"><p>Returns <code>true</code> if <code>self</code> has a negative sign, including <code>-0.0</code>, NaNs with
negative sign bit and negative infinity.</p>
<p>Note that IEEE 754 doesn’t assign any meaning to the sign bit in case of
a NaN, and as Rust doesn’t guarantee that the bit pattern of NaNs are
conserved over arithmetic operations, the result of <code>is_sign_negative</code> on
a NaN might produce an unexpected or non-portable result. See the <a href="primitive.f32.html#nan-bit-patterns" title="primitive f32">specification
of NaN bit patterns</a> for more info. Use <code>self.signum() == -1.0</code>
if you need fully portable behavior (will return <code>false</code> for all NaNs).</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(f128)]

</span><span class="kw">let </span>f = <span class="number">7.0_f128</span>;
<span class="kw">let </span>g = -<span class="number">7.0_f128</span>;

<span class="macro">assert!</span>(!f.is_sign_negative());
<span class="macro">assert!</span>(g.is_sign_negative());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(f128)%5D%0A%0Afn+main()+%7B%0A++++let+f+=+7.0_f128;%0A++++let+g+=+-7.0_f128;%0A++++%0A++++assert!(!f.is_sign_negative());%0A++++assert!(g.is_sign_negative());%0A%7D&amp;version=nightly&amp;edition=2021"></a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.next_up" class="method"><a class="src rightside" href="../src/core/num/f128.rs.html#526-544">Source</a><h4 class="code-header">pub const fn <a href="#method.next_up" class="fn">next_up</a>(self) -&gt; Self</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>f128</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/116909">#116909</a>)</span></div></span></summary><div class="docblock"><p>Returns the least number greater than <code>self</code>.</p>
<p>Let <code>TINY</code> be the smallest representable positive <code>f128</code>. Then,</p>
<ul>
<li>if <code>self.is_nan()</code>, this returns <code>self</code>;</li>
<li>if <code>self</code> is <a href="primitive.f128.html#associatedconstant.NEG_INFINITY" title="associated constant f128::NEG_INFINITY"><code>NEG_INFINITY</code></a>, this returns <a href="primitive.f128.html#associatedconstant.MIN" title="associated constant f128::MIN"><code>MIN</code></a>;</li>
<li>if <code>self</code> is <code>-TINY</code>, this returns -0.0;</li>
<li>if <code>self</code> is -0.0 or +0.0, this returns <code>TINY</code>;</li>
<li>if <code>self</code> is <a href="primitive.f128.html#associatedconstant.MAX" title="associated constant f128::MAX"><code>MAX</code></a> or <a href="primitive.f128.html#associatedconstant.INFINITY" title="associated constant f128::INFINITY"><code>INFINITY</code></a>, this returns <a href="primitive.f128.html#associatedconstant.INFINITY" title="associated constant f128::INFINITY"><code>INFINITY</code></a>;</li>
<li>otherwise the unique least value greater than <code>self</code> is returned.</li>
</ul>
<p>The identity <code>x.next_up() == -(-x).next_down()</code> holds for all non-NaN <code>x</code>. When <code>x</code>
is finite <code>x == x.next_up().next_down()</code> also holds.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(f128)]
#![feature(float_next_up_down)]

</span><span class="comment">// f128::EPSILON is the difference between 1.0 and the next number up.
</span><span class="macro">assert_eq!</span>(<span class="number">1.0f128</span>.next_up(), <span class="number">1.0 </span>+ f128::EPSILON);
<span class="comment">// But not for most numbers.
</span><span class="macro">assert!</span>(<span class="number">0.1f128</span>.next_up() &lt; <span class="number">0.1 </span>+ f128::EPSILON);
<span class="macro">assert_eq!</span>(<span class="number">4611686018427387904f128</span>.next_up(), <span class="number">4611686018427387904.000000000000001</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(f128)%5D%0A%23!%5Bfeature(float_next_up_down)%5D%0A//+FIXME(f16_f128):+remove+when+%60eqtf2%60+is+available%0Afn+main()+%7B%0A++++%23%5Bcfg(all(target_arch+=+%22x86_64%22,+target_os+=+%22linux%22))%5D+%7B%0A++++%0A++++//+f128::EPSILON+is+the+difference+between+1.0+and+the+next+number+up.%0A++++assert_eq!(1.0f128.next_up(),+1.0+%2B+f128::EPSILON);%0A++++//+But+not+for+most+numbers.%0A++++assert!(0.1f128.next_up()+%3C+0.1+%2B+f128::EPSILON);%0A++++assert_eq!(4611686018427387904f128.next_up(),+4611686018427387904.000000000000001);%0A++++%7D%0A%7D&amp;version=nightly&amp;edition=2021"></a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.next_down" class="method"><a class="src rightside" href="../src/core/num/f128.rs.html#580-598">Source</a><h4 class="code-header">pub const fn <a href="#method.next_down" class="fn">next_down</a>(self) -&gt; Self</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>f128</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/116909">#116909</a>)</span></div></span></summary><div class="docblock"><p>Returns the greatest number less than <code>self</code>.</p>
<p>Let <code>TINY</code> be the smallest representable positive <code>f128</code>. Then,</p>
<ul>
<li>if <code>self.is_nan()</code>, this returns <code>self</code>;</li>
<li>if <code>self</code> is <a href="primitive.f128.html#associatedconstant.INFINITY" title="associated constant f128::INFINITY"><code>INFINITY</code></a>, this returns <a href="primitive.f128.html#associatedconstant.MAX" title="associated constant f128::MAX"><code>MAX</code></a>;</li>
<li>if <code>self</code> is <code>TINY</code>, this returns 0.0;</li>
<li>if <code>self</code> is -0.0 or +0.0, this returns <code>-TINY</code>;</li>
<li>if <code>self</code> is <a href="primitive.f128.html#associatedconstant.MIN" title="associated constant f128::MIN"><code>MIN</code></a> or <a href="primitive.f128.html#associatedconstant.NEG_INFINITY" title="associated constant f128::NEG_INFINITY"><code>NEG_INFINITY</code></a>, this returns <a href="primitive.f128.html#associatedconstant.NEG_INFINITY" title="associated constant f128::NEG_INFINITY"><code>NEG_INFINITY</code></a>;</li>
<li>otherwise the unique greatest value less than <code>self</code> is returned.</li>
</ul>
<p>The identity <code>x.next_down() == -(-x).next_up()</code> holds for all non-NaN <code>x</code>. When <code>x</code>
is finite <code>x == x.next_down().next_up()</code> also holds.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(f128)]
#![feature(float_next_up_down)]

</span><span class="kw">let </span>x = <span class="number">1.0f128</span>;
<span class="comment">// Clamp value into range [0, 1).
</span><span class="kw">let </span>clamped = x.clamp(<span class="number">0.0</span>, <span class="number">1.0f128</span>.next_down());
<span class="macro">assert!</span>(clamped &lt; <span class="number">1.0</span>);
<span class="macro">assert_eq!</span>(clamped.next_up(), <span class="number">1.0</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(f128)%5D%0A%23!%5Bfeature(float_next_up_down)%5D%0A//+FIXME(f16_f128):+remove+when+%60eqtf2%60+is+available%0Afn+main()+%7B%0A++++%23%5Bcfg(all(target_arch+=+%22x86_64%22,+target_os+=+%22linux%22))%5D+%7B%0A++++%0A++++let+x+=+1.0f128;%0A++++//+Clamp+value+into+range+%5B0,+1).%0A++++let+clamped+=+x.clamp(0.0,+1.0f128.next_down());%0A++++assert!(clamped+%3C+1.0);%0A++++assert_eq!(clamped.next_up(),+1.0);%0A++++%7D%0A%7D&amp;version=nightly&amp;edition=2021"></a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.recip" class="method"><a class="src rightside" href="../src/core/num/f128.rs.html#617-619">Source</a><h4 class="code-header">pub const fn <a href="#method.recip" class="fn">recip</a>(self) -&gt; Self</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>f128</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/116909">#116909</a>)</span></div></span></summary><div class="docblock"><p>Takes the reciprocal (inverse) of a number, <code>1/x</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(f128)]

</span><span class="kw">let </span>x = <span class="number">2.0_f128</span>;
<span class="kw">let </span>abs_difference = (x.recip() - (<span class="number">1.0 </span>/ x)).abs();

<span class="macro">assert!</span>(abs_difference &lt;= f128::EPSILON);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(f128)%5D%0A//+FIXME(f16_f128):+remove+when+%60eqtf2%60+is+available%0Afn+main()+%7B%0A++++%23%5Bcfg(all(target_arch+=+%22x86_64%22,+target_os+=+%22linux%22))%5D+%7B%0A++++%0A++++let+x+=+2.0_f128;%0A++++let+abs_difference+=+(x.recip()+-+(1.0+/+x)).abs();%0A++++%0A++++assert!(abs_difference+%3C=+f128::EPSILON);%0A++++%7D%0A%7D&amp;version=nightly&amp;edition=2021"></a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.to_degrees" class="method"><a class="src rightside" href="../src/core/num/f128.rs.html#638-642">Source</a><h4 class="code-header">pub const fn <a href="#method.to_degrees" class="fn">to_degrees</a>(self) -&gt; Self</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>f128</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/116909">#116909</a>)</span></div></span></summary><div class="docblock"><p>Converts radians to degrees.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(f128)]

</span><span class="kw">let </span>angle = std::f128::consts::PI;

<span class="kw">let </span>abs_difference = (angle.to_degrees() - <span class="number">180.0</span>).abs();
<span class="macro">assert!</span>(abs_difference &lt;= f128::EPSILON);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(f128)%5D%0A//+FIXME(f16_f128):+remove+when+%60eqtf2%60+is+available%0Afn+main()+%7B%0A++++%23%5Bcfg(all(target_arch+=+%22x86_64%22,+target_os+=+%22linux%22))%5D+%7B%0A++++%0A++++let+angle+=+std::f128::consts::PI;%0A++++%0A++++let+abs_difference+=+(angle.to_degrees()+-+180.0).abs();%0A++++assert!(abs_difference+%3C=+f128::EPSILON);%0A++++%7D%0A%7D&amp;version=nightly&amp;edition=2021"></a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.to_radians" class="method"><a class="src rightside" href="../src/core/num/f128.rs.html#662-667">Source</a><h4 class="code-header">pub const fn <a href="#method.to_radians" class="fn">to_radians</a>(self) -&gt; <a class="primitive" href="primitive.f128.html">f128</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>f128</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/116909">#116909</a>)</span></div></span></summary><div class="docblock"><p>Converts degrees to radians.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(f128)]

</span><span class="kw">let </span>angle = <span class="number">180.0f128</span>;

<span class="kw">let </span>abs_difference = (angle.to_radians() - std::f128::consts::PI).abs();

<span class="macro">assert!</span>(abs_difference &lt;= <span class="number">1e-30</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(f128)%5D%0A//+FIXME(f16_f128):+remove+when+%60eqtf2%60+is+available%0Afn+main()+%7B%0A++++%23%5Bcfg(all(target_arch+=+%22x86_64%22,+target_os+=+%22linux%22))%5D+%7B%0A++++%0A++++let+angle+=+180.0f128;%0A++++%0A++++let+abs_difference+=+(angle.to_radians()+-+std::f128::consts::PI).abs();%0A++++%0A++++assert!(abs_difference+%3C=+1e-30);%0A++++%7D%0A%7D&amp;version=nightly&amp;edition=2021"></a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.max" class="method"><a class="src rightside" href="../src/core/num/f128.rs.html#691-693">Source</a><h4 class="code-header">pub const fn <a href="#method.max" class="fn">max</a>(self, other: <a class="primitive" href="primitive.f128.html">f128</a>) -&gt; <a class="primitive" href="primitive.f128.html">f128</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>f128</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/116909">#116909</a>)</span></div></span></summary><div class="docblock"><p>Returns the maximum of the two numbers, ignoring NaN.</p>
<p>If one of the arguments is NaN, then the other argument is returned.
This follows the IEEE 754-2008 semantics for maxNum, except for handling of signaling NaNs;
this function handles all NaNs the same way and avoids maxNum’s problems with associativity.
This also matches the behavior of libm’s fmax.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(f128)]

</span><span class="kw">let </span>x = <span class="number">1.0f128</span>;
<span class="kw">let </span>y = <span class="number">2.0f128</span>;

<span class="macro">assert_eq!</span>(x.max(y), y);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(f128)%5D%0A//+Using+aarch64+because+%60reliable_f128_math%60+is+needed%0Afn+main()+%7B%0A++++%23%5Bcfg(all(target_arch+=+%22aarch64%22,+target_os+=+%22linux%22))%5D+%7B%0A++++%0A++++let+x+=+1.0f128;%0A++++let+y+=+2.0f128;%0A++++%0A++++assert_eq!(x.max(y),+y);%0A++++%7D%0A%7D&amp;version=nightly&amp;edition=2021"></a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.min" class="method"><a class="src rightside" href="../src/core/num/f128.rs.html#717-719">Source</a><h4 class="code-header">pub const fn <a href="#method.min" class="fn">min</a>(self, other: <a class="primitive" href="primitive.f128.html">f128</a>) -&gt; <a class="primitive" href="primitive.f128.html">f128</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>f128</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/116909">#116909</a>)</span></div></span></summary><div class="docblock"><p>Returns the minimum of the two numbers, ignoring NaN.</p>
<p>If one of the arguments is NaN, then the other argument is returned.
This follows the IEEE 754-2008 semantics for minNum, except for handling of signaling NaNs;
this function handles all NaNs the same way and avoids minNum’s problems with associativity.
This also matches the behavior of libm’s fmin.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(f128)]

</span><span class="kw">let </span>x = <span class="number">1.0f128</span>;
<span class="kw">let </span>y = <span class="number">2.0f128</span>;

<span class="macro">assert_eq!</span>(x.min(y), x);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(f128)%5D%0A//+Using+aarch64+because+%60reliable_f128_math%60+is+needed%0Afn+main()+%7B%0A++++%23%5Bcfg(all(target_arch+=+%22aarch64%22,+target_os+=+%22linux%22))%5D+%7B%0A++++%0A++++let+x+=+1.0f128;%0A++++let+y+=+2.0f128;%0A++++%0A++++assert_eq!(x.min(y),+x);%0A++++%7D%0A%7D&amp;version=nightly&amp;edition=2021"></a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.maximum" class="method"><a class="src rightside" href="../src/core/num/f128.rs.html#750-760">Source</a><h4 class="code-header">pub const fn <a href="#method.maximum" class="fn">maximum</a>(self, other: <a class="primitive" href="primitive.f128.html">f128</a>) -&gt; <a class="primitive" href="primitive.f128.html">f128</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>f128</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/116909">#116909</a>)</span></div></span></summary><div class="docblock"><p>Returns the maximum of the two numbers, propagating NaN.</p>
<p>This returns NaN when <em>either</em> argument is NaN, as opposed to
<a href="primitive.f128.html#method.max" title="method f128::max"><code>f128::max</code></a> which only returns NaN when <em>both</em> arguments are NaN.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(f128)]
#![feature(float_minimum_maximum)]

</span><span class="kw">let </span>x = <span class="number">1.0f128</span>;
<span class="kw">let </span>y = <span class="number">2.0f128</span>;

<span class="macro">assert_eq!</span>(x.maximum(y), y);
<span class="macro">assert!</span>(x.maximum(f128::NAN).is_nan());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(f128)%5D%0A%23!%5Bfeature(float_minimum_maximum)%5D%0A//+Using+aarch64+because+%60reliable_f128_math%60+is+needed%0Afn+main()+%7B%0A++++%23%5Bcfg(all(target_arch+=+%22aarch64%22,+target_os+=+%22linux%22))%5D+%7B%0A++++%0A++++let+x+=+1.0f128;%0A++++let+y+=+2.0f128;%0A++++%0A++++assert_eq!(x.maximum(y),+y);%0A++++assert!(x.maximum(f128::NAN).is_nan());%0A++++%7D%0A%7D&amp;version=nightly&amp;edition=2021"></a></div>
<p>If one of the arguments is NaN, then NaN is returned. Otherwise this returns the greater
of the two numbers. For this operation, -0.0 is considered to be less than +0.0.
Note that this follows the semantics specified in IEEE 754-2019.</p>
<p>Also note that “propagation” of NaNs here doesn’t necessarily mean that the bitpattern of a NaN
operand is conserved; see the <a href="primitive.f32.html#nan-bit-patterns" title="primitive f32">specification of NaN bit patterns</a> for more info.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.minimum" class="method"><a class="src rightside" href="../src/core/num/f128.rs.html#791-802">Source</a><h4 class="code-header">pub const fn <a href="#method.minimum" class="fn">minimum</a>(self, other: <a class="primitive" href="primitive.f128.html">f128</a>) -&gt; <a class="primitive" href="primitive.f128.html">f128</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>f128</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/116909">#116909</a>)</span></div></span></summary><div class="docblock"><p>Returns the minimum of the two numbers, propagating NaN.</p>
<p>This returns NaN when <em>either</em> argument is NaN, as opposed to
<a href="primitive.f128.html#method.min" title="method f128::min"><code>f128::min</code></a> which only returns NaN when <em>both</em> arguments are NaN.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(f128)]
#![feature(float_minimum_maximum)]

</span><span class="kw">let </span>x = <span class="number">1.0f128</span>;
<span class="kw">let </span>y = <span class="number">2.0f128</span>;

<span class="macro">assert_eq!</span>(x.minimum(y), x);
<span class="macro">assert!</span>(x.minimum(f128::NAN).is_nan());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(f128)%5D%0A%23!%5Bfeature(float_minimum_maximum)%5D%0A//+Using+aarch64+because+%60reliable_f128_math%60+is+needed%0Afn+main()+%7B%0A++++%23%5Bcfg(all(target_arch+=+%22aarch64%22,+target_os+=+%22linux%22))%5D+%7B%0A++++%0A++++let+x+=+1.0f128;%0A++++let+y+=+2.0f128;%0A++++%0A++++assert_eq!(x.minimum(y),+x);%0A++++assert!(x.minimum(f128::NAN).is_nan());%0A++++%7D%0A%7D&amp;version=nightly&amp;edition=2021"></a></div>
<p>If one of the arguments is NaN, then NaN is returned. Otherwise this returns the lesser
of the two numbers. For this operation, -0.0 is considered to be less than +0.0.
Note that this follows the semantics specified in IEEE 754-2019.</p>
<p>Also note that “propagation” of NaNs here doesn’t necessarily mean that the bitpattern of a NaN
operand is conserved; see the <a href="primitive.f32.html#nan-bit-patterns" title="primitive f32">specification of NaN bit patterns</a> for more info.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.midpoint" class="method"><a class="src rightside" href="../src/core/num/f128.rs.html#824-845">Source</a><h4 class="code-header">pub fn <a href="#method.midpoint" class="fn">midpoint</a>(self, other: <a class="primitive" href="primitive.f128.html">f128</a>) -&gt; <a class="primitive" href="primitive.f128.html">f128</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>f128</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/116909">#116909</a>)</span></div></span></summary><div class="docblock"><p>Calculates the middle point of <code>self</code> and <code>rhs</code>.</p>
<p>This returns NaN when <em>either</em> argument is NaN or if a combination of
+inf and -inf is provided as arguments.</p>
<h5 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(f128)]
#![feature(num_midpoint)]

</span><span class="macro">assert_eq!</span>(<span class="number">1f128</span>.midpoint(<span class="number">4.0</span>), <span class="number">2.5</span>);
<span class="macro">assert_eq!</span>((-<span class="number">5.5f128</span>).midpoint(<span class="number">8.0</span>), <span class="number">1.25</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(f128)%5D%0A%23!%5Bfeature(num_midpoint)%5D%0A//+Using+aarch64+because+%60reliable_f128_math%60+is+needed%0Afn+main()+%7B%0A++++%23%5Bcfg(all(target_arch+=+%22aarch64%22,+target_os+=+%22linux%22))%5D+%7B%0A++++%0A++++assert_eq!(1f128.midpoint(4.0),+2.5);%0A++++assert_eq!((-5.5f128).midpoint(8.0),+1.25);%0A++++%7D%0A%7D&amp;version=nightly&amp;edition=2021"></a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.to_int_unchecked" class="method"><a class="src rightside" href="../src/core/num/f128.rs.html#875-882">Source</a><h4 class="code-header">pub unsafe fn <a href="#method.to_int_unchecked" class="fn">to_int_unchecked</a>&lt;Int&gt;(self) -&gt; Int<div class="where">where
    Self: <a class="trait" href="convert/trait.FloatToInt.html" title="trait core::convert::FloatToInt">FloatToInt</a>&lt;Int&gt;,</div></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>f128</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/116909">#116909</a>)</span></div></span></summary><div class="docblock"><p>Rounds toward zero and converts to any primitive integer type,
assuming that the value is finite and fits in that type.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(f128)]

</span><span class="kw">let </span>value = <span class="number">4.6_f128</span>;
<span class="kw">let </span>rounded = <span class="kw">unsafe </span>{ value.to_int_unchecked::&lt;u16&gt;() };
<span class="macro">assert_eq!</span>(rounded, <span class="number">4</span>);

<span class="kw">let </span>value = -<span class="number">128.9_f128</span>;
<span class="kw">let </span>rounded = <span class="kw">unsafe </span>{ value.to_int_unchecked::&lt;i8&gt;() };
<span class="macro">assert_eq!</span>(rounded, i8::MIN);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(f128)%5D%0A//+FIXME(f16_f128):+remove+when+%60float*itf%60+is+available%0Afn+main()+%7B%0A++++%23%5Bcfg(all(target_arch+=+%22x86_64%22,+target_os+=+%22linux%22))%5D+%7B%0A++++%0A++++let+value+=+4.6_f128;%0A++++let+rounded+=+unsafe+%7B+value.to_int_unchecked::%3Cu16%3E()+%7D;%0A++++assert_eq!(rounded,+4);%0A++++%0A++++let+value+=+-128.9_f128;%0A++++let+rounded+=+unsafe+%7B+value.to_int_unchecked::%3Ci8%3E()+%7D;%0A++++assert_eq!(rounded,+i8::MIN);%0A++++%7D%0A%7D&amp;version=nightly&amp;edition=2021"></a></div>
<h5 id="safety"><a class="doc-anchor" href="#safety">§</a>Safety</h5>
<p>The value must:</p>
<ul>
<li>Not be <code>NaN</code></li>
<li>Not be infinite</li>
<li>Be representable in the return type <code>Int</code>, after truncating off its fractional part</li>
</ul>
</div></details><details class="toggle method-toggle" open><summary><section id="method.to_bits" class="method"><a class="src rightside" href="../src/core/num/f128.rs.html#904-907">Source</a><h4 class="code-header">pub const fn <a href="#method.to_bits" class="fn">to_bits</a>(self) -&gt; <a class="primitive" href="primitive.u128.html">u128</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>f128</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/116909">#116909</a>)</span></div></span></summary><div class="docblock"><p>Raw transmutation to <code>u128</code>.</p>
<p>This is currently identical to <code>transmute::&lt;f128, u128&gt;(self)</code> on all platforms.</p>
<p>See <a href="#method.from_bits"><code>from_bits</code></a> for some discussion of the
portability of this operation (there are almost no issues).</p>
<p>Note that this function is distinct from <code>as</code> casting, which attempts to
preserve the <em>numeric</em> value, and not the bitwise value.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(f128)]

</span><span class="macro">assert_eq!</span>((<span class="number">12.5f128</span>).to_bits(), <span class="number">0x40029000000000000000000000000000</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(f128)%5D%0A%0A//+FIXME(f16_f128):+enable+this+once+const+casting+works%0A//+assert_ne!((1f128).to_bits(),+1f128+as+u128);+//+to_bits()+is+not+casting!%0Afn+main()+%7B%0A++++assert_eq!((12.5f128).to_bits(),+0x40029000000000000000000000000000);%0A%7D&amp;version=nightly&amp;edition=2021"></a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.from_bits" class="method"><a class="src rightside" href="../src/core/num/f128.rs.html#951-955">Source</a><h4 class="code-header">pub const fn <a href="#method.from_bits" class="fn">from_bits</a>(v: <a class="primitive" href="primitive.u128.html">u128</a>) -&gt; Self</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>f128</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/116909">#116909</a>)</span></div></span></summary><div class="docblock"><p>Raw transmutation from <code>u128</code>.</p>
<p>This is currently identical to <code>transmute::&lt;u128, f128&gt;(v)</code> on all platforms.
It turns out this is incredibly portable, for two reasons:</p>
<ul>
<li>Floats and Ints have the same endianness on all supported platforms.</li>
<li>IEEE 754 very precisely specifies the bit layout of floats.</li>
</ul>
<p>However there is one caveat: prior to the 2008 version of IEEE 754, how
to interpret the NaN signaling bit wasn’t actually specified. Most platforms
(notably x86 and ARM) picked the interpretation that was ultimately
standardized in 2008, but some didn’t (notably MIPS). As a result, all
signaling NaNs on MIPS are quiet NaNs on x86, and vice-versa.</p>
<p>Rather than trying to preserve signaling-ness cross-platform, this
implementation favors preserving the exact bits. This means that
any payloads encoded in NaNs will be preserved even if the result of
this method is sent over the network from an x86 machine to a MIPS one.</p>
<p>If the results of this method are only manipulated by the same
architecture that produced them, then there is no portability concern.</p>
<p>If the input isn’t NaN, then there is no portability concern.</p>
<p>If you don’t care about signalingness (very likely), then there is no
portability concern.</p>
<p>Note that this function is distinct from <code>as</code> casting, which attempts to
preserve the <em>numeric</em> value, and not the bitwise value.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(f128)]

</span><span class="kw">let </span>v = f128::from_bits(<span class="number">0x40029000000000000000000000000000</span>);
<span class="macro">assert_eq!</span>(v, <span class="number">12.5</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(f128)%5D%0A+//+FIXME(f16_f128):+remove+when+%60eqtf2%60+is+available%0Afn+main()+%7B%0A++++%23%5Bcfg(all(target_arch+=+%22x86_64%22,+target_os+=+%22linux%22))%5D+%7B%0A++++%0A++++let+v+=+f128::from_bits(0x40029000000000000000000000000000);%0A++++assert_eq!(v,+12.5);%0A++++%7D%0A%7D&amp;version=nightly&amp;edition=2021"></a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.to_be_bytes" class="method"><a class="src rightside" href="../src/core/num/f128.rs.html#978-980">Source</a><h4 class="code-header">pub const fn <a href="#method.to_be_bytes" class="fn">to_be_bytes</a>(self) -&gt; [<a class="primitive" href="primitive.u8.html">u8</a>; <a class="primitive" href="primitive.array.html">16</a>]</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>f128</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/116909">#116909</a>)</span></div></span></summary><div class="docblock"><p>Returns the memory representation of this floating point number as a byte array in
big-endian (network) byte order.</p>
<p>See <a href="primitive.f128.html#method.from_bits" title="associated function f128::from_bits"><code>from_bits</code></a> for some discussion of the
portability of this operation (there are almost no issues).</p>
<h5 id="examples-1"><a class="doc-anchor" href="#examples-1">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(f128)]

</span><span class="kw">let </span>bytes = <span class="number">12.5f128</span>.to_be_bytes();
<span class="macro">assert_eq!</span>(
    bytes,
    [<span class="number">0x40</span>, <span class="number">0x02</span>, <span class="number">0x90</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,
     <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>]
);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(f128)%5D%0A%0Afn+main()+%7B%0A++++let+bytes+=+12.5f128.to_be_bytes();%0A++++assert_eq!(%0A++++++++bytes,%0A++++++++%5B0x40,+0x02,+0x90,+0x00,+0x00,+0x00,+0x00,+0x00,%0A+++++++++0x00,+0x00,+0x00,+0x00,+0x00,+0x00,+0x00,+0x00%5D%0A++++);%0A%7D&amp;version=nightly&amp;edition=2021"></a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.to_le_bytes" class="method"><a class="src rightside" href="../src/core/num/f128.rs.html#1003-1005">Source</a><h4 class="code-header">pub const fn <a href="#method.to_le_bytes" class="fn">to_le_bytes</a>(self) -&gt; [<a class="primitive" href="primitive.u8.html">u8</a>; <a class="primitive" href="primitive.array.html">16</a>]</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>f128</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/116909">#116909</a>)</span></div></span></summary><div class="docblock"><p>Returns the memory representation of this floating point number as a byte array in
little-endian byte order.</p>
<p>See <a href="primitive.f128.html#method.from_bits" title="associated function f128::from_bits"><code>from_bits</code></a> for some discussion of the
portability of this operation (there are almost no issues).</p>
<h5 id="examples-2"><a class="doc-anchor" href="#examples-2">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(f128)]

</span><span class="kw">let </span>bytes = <span class="number">12.5f128</span>.to_le_bytes();
<span class="macro">assert_eq!</span>(
    bytes,
    [<span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,
     <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x90</span>, <span class="number">0x02</span>, <span class="number">0x40</span>]
);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(f128)%5D%0A%0Afn+main()+%7B%0A++++let+bytes+=+12.5f128.to_le_bytes();%0A++++assert_eq!(%0A++++++++bytes,%0A++++++++%5B0x00,+0x00,+0x00,+0x00,+0x00,+0x00,+0x00,+0x00,%0A+++++++++0x00,+0x00,+0x00,+0x00,+0x00,+0x90,+0x02,+0x40%5D%0A++++);%0A%7D&amp;version=nightly&amp;edition=2021"></a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.to_ne_bytes" class="method"><a class="src rightside" href="../src/core/num/f128.rs.html#1039-1041">Source</a><h4 class="code-header">pub const fn <a href="#method.to_ne_bytes" class="fn">to_ne_bytes</a>(self) -&gt; [<a class="primitive" href="primitive.u8.html">u8</a>; <a class="primitive" href="primitive.array.html">16</a>]</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>f128</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/116909">#116909</a>)</span></div></span></summary><div class="docblock"><p>Returns the memory representation of this floating point number as a byte array in
native byte order.</p>
<p>As the target platform’s native endianness is used, portable code
should use <a href="primitive.f128.html#method.to_be_bytes" title="method f128::to_be_bytes"><code>to_be_bytes</code></a> or <a href="primitive.f128.html#method.to_le_bytes" title="method f128::to_le_bytes"><code>to_le_bytes</code></a>, as appropriate, instead.</p>
<p>See <a href="primitive.f128.html#method.from_bits" title="associated function f128::from_bits"><code>from_bits</code></a> for some discussion of the
portability of this operation (there are almost no issues).</p>
<h5 id="examples-3"><a class="doc-anchor" href="#examples-3">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(f128)]

</span><span class="kw">let </span>bytes = <span class="number">12.5f128</span>.to_ne_bytes();
<span class="macro">assert_eq!</span>(
    bytes,
    <span class="kw">if </span><span class="macro">cfg!</span>(target_endian = <span class="string">"big"</span>) {
        [<span class="number">0x40</span>, <span class="number">0x02</span>, <span class="number">0x90</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,
         <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>]
    } <span class="kw">else </span>{
        [<span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,
         <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x90</span>, <span class="number">0x02</span>, <span class="number">0x40</span>]
    }
);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(f128)%5D%0A%0Afn+main()+%7B%0A++++let+bytes+=+12.5f128.to_ne_bytes();%0A++++assert_eq!(%0A++++++++bytes,%0A++++++++if+cfg!(target_endian+=+%22big%22)+%7B%0A++++++++++++%5B0x40,+0x02,+0x90,+0x00,+0x00,+0x00,+0x00,+0x00,%0A+++++++++++++0x00,+0x00,+0x00,+0x00,+0x00,+0x00,+0x00,+0x00%5D%0A++++++++%7D+else+%7B%0A++++++++++++%5B0x00,+0x00,+0x00,+0x00,+0x00,+0x00,+0x00,+0x00,%0A+++++++++++++0x00,+0x00,+0x00,+0x00,+0x00,+0x90,+0x02,+0x40%5D%0A++++++++%7D%0A++++);%0A%7D&amp;version=nightly&amp;edition=2021"></a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.from_be_bytes" class="method"><a class="src rightside" href="../src/core/num/f128.rs.html#1065-1067">Source</a><h4 class="code-header">pub const fn <a href="#method.from_be_bytes" class="fn">from_be_bytes</a>(bytes: [<a class="primitive" href="primitive.u8.html">u8</a>; <a class="primitive" href="primitive.array.html">16</a>]) -&gt; Self</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>f128</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/116909">#116909</a>)</span></div></span></summary><div class="docblock"><p>Creates a floating point value from its representation as a byte array in big endian.</p>
<p>See <a href="primitive.f128.html#method.from_bits" title="associated function f128::from_bits"><code>from_bits</code></a> for some discussion of the
portability of this operation (there are almost no issues).</p>
<h5 id="examples-4"><a class="doc-anchor" href="#examples-4">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(f128)]

</span><span class="kw">let </span>value = f128::from_be_bytes(
    [<span class="number">0x40</span>, <span class="number">0x02</span>, <span class="number">0x90</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,
     <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>]
);
<span class="macro">assert_eq!</span>(value, <span class="number">12.5</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(f128)%5D%0A//+FIXME(f16_f128):+remove+when+%60eqtf2%60+is+available%0Afn+main()+%7B%0A++++%23%5Bcfg(all(target_arch+=+%22x86_64%22,+target_os+=+%22linux%22))%5D+%7B%0A++++%0A++++let+value+=+f128::from_be_bytes(%0A++++++++%5B0x40,+0x02,+0x90,+0x00,+0x00,+0x00,+0x00,+0x00,%0A+++++++++0x00,+0x00,+0x00,+0x00,+0x00,+0x00,+0x00,+0x00%5D%0A++++);%0A++++assert_eq!(value,+12.5);%0A++++%7D%0A%7D&amp;version=nightly&amp;edition=2021"></a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.from_le_bytes" class="method"><a class="src rightside" href="../src/core/num/f128.rs.html#1091-1093">Source</a><h4 class="code-header">pub const fn <a href="#method.from_le_bytes" class="fn">from_le_bytes</a>(bytes: [<a class="primitive" href="primitive.u8.html">u8</a>; <a class="primitive" href="primitive.array.html">16</a>]) -&gt; Self</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>f128</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/116909">#116909</a>)</span></div></span></summary><div class="docblock"><p>Creates a floating point value from its representation as a byte array in little endian.</p>
<p>See <a href="primitive.f128.html#method.from_bits" title="associated function f128::from_bits"><code>from_bits</code></a> for some discussion of the
portability of this operation (there are almost no issues).</p>
<h5 id="examples-5"><a class="doc-anchor" href="#examples-5">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(f128)]

</span><span class="kw">let </span>value = f128::from_le_bytes(
    [<span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,
     <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x90</span>, <span class="number">0x02</span>, <span class="number">0x40</span>]
);
<span class="macro">assert_eq!</span>(value, <span class="number">12.5</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(f128)%5D%0A//+FIXME(f16_f128):+remove+when+%60eqtf2%60+is+available%0Afn+main()+%7B%0A++++%23%5Bcfg(all(target_arch+=+%22x86_64%22,+target_os+=+%22linux%22))%5D+%7B%0A++++%0A++++let+value+=+f128::from_le_bytes(%0A++++++++%5B0x00,+0x00,+0x00,+0x00,+0x00,+0x00,+0x00,+0x00,%0A+++++++++0x00,+0x00,+0x00,+0x00,+0x00,+0x90,+0x02,+0x40%5D%0A++++);%0A++++assert_eq!(value,+12.5);%0A++++%7D%0A%7D&amp;version=nightly&amp;edition=2021"></a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.from_ne_bytes" class="method"><a class="src rightside" href="../src/core/num/f128.rs.html#1127-1129">Source</a><h4 class="code-header">pub const fn <a href="#method.from_ne_bytes" class="fn">from_ne_bytes</a>(bytes: [<a class="primitive" href="primitive.u8.html">u8</a>; <a class="primitive" href="primitive.array.html">16</a>]) -&gt; Self</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>f128</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/116909">#116909</a>)</span></div></span></summary><div class="docblock"><p>Creates a floating point value from its representation as a byte array in native endian.</p>
<p>As the target platform’s native endianness is used, portable code
likely wants to use <a href="primitive.f128.html#method.from_be_bytes" title="associated function f128::from_be_bytes"><code>from_be_bytes</code></a> or <a href="primitive.f128.html#method.from_le_bytes" title="associated function f128::from_le_bytes"><code>from_le_bytes</code></a>, as
appropriate instead.</p>
<p>See <a href="primitive.f128.html#method.from_bits" title="associated function f128::from_bits"><code>from_bits</code></a> for some discussion of the
portability of this operation (there are almost no issues).</p>
<h5 id="examples-6"><a class="doc-anchor" href="#examples-6">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(f128)]

</span><span class="kw">let </span>value = f128::from_ne_bytes(<span class="kw">if </span><span class="macro">cfg!</span>(target_endian = <span class="string">"big"</span>) {
    [<span class="number">0x40</span>, <span class="number">0x02</span>, <span class="number">0x90</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,
     <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>]
} <span class="kw">else </span>{
    [<span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,
     <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x90</span>, <span class="number">0x02</span>, <span class="number">0x40</span>]
});
<span class="macro">assert_eq!</span>(value, <span class="number">12.5</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(f128)%5D%0A//+FIXME(f16_f128):+remove+when+%60eqtf2%60+is+available%0Afn+main()+%7B%0A++++%23%5Bcfg(all(target_arch+=+%22x86_64%22,+target_os+=+%22linux%22))%5D+%7B%0A++++%0A++++let+value+=+f128::from_ne_bytes(if+cfg!(target_endian+=+%22big%22)+%7B%0A++++++++%5B0x40,+0x02,+0x90,+0x00,+0x00,+0x00,+0x00,+0x00,%0A+++++++++0x00,+0x00,+0x00,+0x00,+0x00,+0x00,+0x00,+0x00%5D%0A++++%7D+else+%7B%0A++++++++%5B0x00,+0x00,+0x00,+0x00,+0x00,+0x00,+0x00,+0x00,%0A+++++++++0x00,+0x00,+0x00,+0x00,+0x00,+0x90,+0x02,+0x40%5D%0A++++%7D);%0A++++assert_eq!(value,+12.5);%0A++++%7D%0A%7D&amp;version=nightly&amp;edition=2021"></a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.total_cmp" class="method"><a class="src rightside" href="../src/core/num/f128.rs.html#1195-1225">Source</a><h4 class="code-header">pub fn <a href="#method.total_cmp" class="fn">total_cmp</a>(&amp;self, other: &amp;Self) -&gt; <a class="enum" href="cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>f128</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/116909">#116909</a>)</span></div></span></summary><div class="docblock"><p>Returns the ordering between <code>self</code> and <code>other</code>.</p>
<p>Unlike the standard partial comparison between floating point numbers,
this comparison always produces an ordering in accordance to
the <code>totalOrder</code> predicate as defined in the IEEE 754 (2008 revision)
floating point standard. The values are ordered in the following sequence:</p>
<ul>
<li>negative quiet NaN</li>
<li>negative signaling NaN</li>
<li>negative infinity</li>
<li>negative numbers</li>
<li>negative subnormal numbers</li>
<li>negative zero</li>
<li>positive zero</li>
<li>positive subnormal numbers</li>
<li>positive numbers</li>
<li>positive infinity</li>
<li>positive signaling NaN</li>
<li>positive quiet NaN.</li>
</ul>
<p>The ordering established by this function does not always agree with the
<a href="cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd"><code>PartialOrd</code></a> and <a href="cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq"><code>PartialEq</code></a> implementations of <code>f128</code>. For example,
they consider negative and positive zero equal, while <code>total_cmp</code>
doesn’t.</p>
<p>The interpretation of the signaling NaN bit follows the definition in
the IEEE 754 standard, which may not match the interpretation by some of
the older, non-conformant (e.g. MIPS) hardware implementations.</p>
<h5 id="example"><a class="doc-anchor" href="#example">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(f128)]

</span><span class="kw">struct </span>GoodBoy {
    name: <span class="kw-2">&amp;</span><span class="lifetime">'static </span>str,
    weight: f128,
}

<span class="kw">let </span><span class="kw-2">mut </span>bois = <span class="macro">vec!</span>[
    GoodBoy { name: <span class="string">"Pucci"</span>, weight: <span class="number">0.1 </span>},
    GoodBoy { name: <span class="string">"Woofer"</span>, weight: <span class="number">99.0 </span>},
    GoodBoy { name: <span class="string">"Yapper"</span>, weight: <span class="number">10.0 </span>},
    GoodBoy { name: <span class="string">"Chonk"</span>, weight: f128::INFINITY },
    GoodBoy { name: <span class="string">"Abs. Unit"</span>, weight: f128::NAN },
    GoodBoy { name: <span class="string">"Floaty"</span>, weight: -<span class="number">5.0 </span>},
];

bois.sort_by(|a, b| a.weight.total_cmp(<span class="kw-2">&amp;</span>b.weight));

<span class="comment">// `f128::NAN` could be positive or negative, which will affect the sort order.
</span><span class="kw">if </span>f128::NAN.is_sign_negative() {
    bois.into_iter().map(|b| b.weight)
        .zip([f128::NAN, -<span class="number">5.0</span>, <span class="number">0.1</span>, <span class="number">10.0</span>, <span class="number">99.0</span>, f128::INFINITY].iter())
        .for_each(|(a, b)| <span class="macro">assert_eq!</span>(a.to_bits(), b.to_bits()))
} <span class="kw">else </span>{
    bois.into_iter().map(|b| b.weight)
        .zip([-<span class="number">5.0</span>, <span class="number">0.1</span>, <span class="number">10.0</span>, <span class="number">99.0</span>, f128::INFINITY, f128::NAN].iter())
        .for_each(|(a, b)| <span class="macro">assert_eq!</span>(a.to_bits(), b.to_bits()))
}</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(f128)%5D%0A%0Afn+main()+%7B%0A++++struct+GoodBoy+%7B%0A++++++++name:+%26'static+str,%0A++++++++weight:+f128,%0A++++%7D%0A++++%0A++++let+mut+bois+=+vec!%5B%0A++++++++GoodBoy+%7B+name:+%22Pucci%22,+weight:+0.1+%7D,%0A++++++++GoodBoy+%7B+name:+%22Woofer%22,+weight:+99.0+%7D,%0A++++++++GoodBoy+%7B+name:+%22Yapper%22,+weight:+10.0+%7D,%0A++++++++GoodBoy+%7B+name:+%22Chonk%22,+weight:+f128::INFINITY+%7D,%0A++++++++GoodBoy+%7B+name:+%22Abs.+Unit%22,+weight:+f128::NAN+%7D,%0A++++++++GoodBoy+%7B+name:+%22Floaty%22,+weight:+-5.0+%7D,%0A++++%5D;%0A++++%0A++++bois.sort_by(%7Ca,+b%7C+a.weight.total_cmp(%26b.weight));%0A++++%0A++++//+%60f128::NAN%60+could+be+positive+or+negative,+which+will+affect+the+sort+order.%0A++++if+f128::NAN.is_sign_negative()+%7B%0A++++++++bois.into_iter().map(%7Cb%7C+b.weight)%0A++++++++++++.zip(%5Bf128::NAN,+-5.0,+0.1,+10.0,+99.0,+f128::INFINITY%5D.iter())%0A++++++++++++.for_each(%7C(a,+b)%7C+assert_eq!(a.to_bits(),+b.to_bits()))%0A++++%7D+else+%7B%0A++++++++bois.into_iter().map(%7Cb%7C+b.weight)%0A++++++++++++.zip(%5B-5.0,+0.1,+10.0,+99.0,+f128::INFINITY,+f128::NAN%5D.iter())%0A++++++++++++.for_each(%7C(a,+b)%7C+assert_eq!(a.to_bits(),+b.to_bits()))%0A++++%7D%0A%7D&amp;version=nightly&amp;edition=2021"></a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.clamp" class="method"><a class="src rightside" href="../src/core/num/f128.rs.html#1256-1272">Source</a><h4 class="code-header">pub const fn <a href="#method.clamp" class="fn">clamp</a>(self, min: <a class="primitive" href="primitive.f128.html">f128</a>, max: <a class="primitive" href="primitive.f128.html">f128</a>) -&gt; <a class="primitive" href="primitive.f128.html">f128</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>f128</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/116909">#116909</a>)</span></div></span></summary><div class="docblock"><p>Restrict a value to a certain interval unless it is NaN.</p>
<p>Returns <code>max</code> if <code>self</code> is greater than <code>max</code>, and <code>min</code> if <code>self</code> is
less than <code>min</code>. Otherwise this returns <code>self</code>.</p>
<p>Note that this function returns NaN if the initial value was NaN as
well.</p>
<h5 id="panics"><a class="doc-anchor" href="#panics">§</a>Panics</h5>
<p>Panics if <code>min &gt; max</code>, <code>min</code> is NaN, or <code>max</code> is NaN.</p>
<h5 id="examples-7"><a class="doc-anchor" href="#examples-7">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(f128)]

</span><span class="macro">assert!</span>((-<span class="number">3.0f128</span>).clamp(-<span class="number">2.0</span>, <span class="number">1.0</span>) == -<span class="number">2.0</span>);
<span class="macro">assert!</span>((<span class="number">0.0f128</span>).clamp(-<span class="number">2.0</span>, <span class="number">1.0</span>) == <span class="number">0.0</span>);
<span class="macro">assert!</span>((<span class="number">2.0f128</span>).clamp(-<span class="number">2.0</span>, <span class="number">1.0</span>) == <span class="number">1.0</span>);
<span class="macro">assert!</span>((f128::NAN).clamp(-<span class="number">2.0</span>, <span class="number">1.0</span>).is_nan());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(f128)%5D%0A//+FIXME(f16_f128):+remove+when+%60%7Beq,gt,unord%7Dtf%60+are+available%0Afn+main()+%7B%0A++++%23%5Bcfg(all(target_arch+=+%22x86_64%22,+target_os+=+%22linux%22))%5D+%7B%0A++++%0A++++assert!((-3.0f128).clamp(-2.0,+1.0)+==+-2.0);%0A++++assert!((0.0f128).clamp(-2.0,+1.0)+==+0.0);%0A++++assert!((2.0f128).clamp(-2.0,+1.0)+==+1.0);%0A++++assert!((f128::NAN).clamp(-2.0,+1.0).is_nan());%0A++++%7D%0A%7D&amp;version=nightly&amp;edition=2021"></a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.abs" class="method"><a class="src rightside" href="../src/core/num/f128.rs.html#1297-1301">Source</a><h4 class="code-header">pub const fn <a href="#method.abs" class="fn">abs</a>(self) -&gt; Self</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>f128</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/116909">#116909</a>)</span></div></span></summary><div class="docblock"><p>Computes the absolute value of <code>self</code>.</p>
<p>This function always returns the precise result.</p>
<h5 id="examples-8"><a class="doc-anchor" href="#examples-8">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(f128)]

</span><span class="kw">let </span>x = <span class="number">3.5_f128</span>;
<span class="kw">let </span>y = -<span class="number">3.5_f128</span>;

<span class="macro">assert_eq!</span>(x.abs(), x);
<span class="macro">assert_eq!</span>(y.abs(), -y);

<span class="macro">assert!</span>(f128::NAN.abs().is_nan());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(f128)%5D%0Afn+main()+%7B%0A++++%23%5Bcfg(all(target_arch+=+%22x86_64%22,+target_os+=+%22linux%22))%5D+%7B%0A++++%0A++++let+x+=+3.5_f128;%0A++++let+y+=+-3.5_f128;%0A++++%0A++++assert_eq!(x.abs(),+x);%0A++++assert_eq!(y.abs(),+-y);%0A++++%0A++++assert!(f128::NAN.abs().is_nan());%0A++++%7D%0A%7D&amp;version=nightly&amp;edition=2021"></a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.signum" class="method"><a class="src rightside" href="../src/core/num/f128.rs.html#1327-1329">Source</a><h4 class="code-header">pub const fn <a href="#method.signum" class="fn">signum</a>(self) -&gt; <a class="primitive" href="primitive.f128.html">f128</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>f128</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/116909">#116909</a>)</span></div></span></summary><div class="docblock"><p>Returns a number that represents the sign of <code>self</code>.</p>
<ul>
<li><code>1.0</code> if the number is positive, <code>+0.0</code> or <code>INFINITY</code></li>
<li><code>-1.0</code> if the number is negative, <code>-0.0</code> or <code>NEG_INFINITY</code></li>
<li>NaN if the number is NaN</li>
</ul>
<h5 id="examples-9"><a class="doc-anchor" href="#examples-9">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(f128)]

</span><span class="kw">let </span>f = <span class="number">3.5_f128</span>;

<span class="macro">assert_eq!</span>(f.signum(), <span class="number">1.0</span>);
<span class="macro">assert_eq!</span>(f128::NEG_INFINITY.signum(), -<span class="number">1.0</span>);

<span class="macro">assert!</span>(f128::NAN.signum().is_nan());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(f128)%5D%0Afn+main()+%7B%0A++++%23%5Bcfg(all(target_arch+=+%22x86_64%22,+target_os+=+%22linux%22))%5D+%7B%0A++++%0A++++let+f+=+3.5_f128;%0A++++%0A++++assert_eq!(f.signum(),+1.0);%0A++++assert_eq!(f128::NEG_INFINITY.signum(),+-1.0);%0A++++%0A++++assert!(f128::NAN.signum().is_nan());%0A++++%7D%0A%7D&amp;version=nightly&amp;edition=2021"></a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.copysign" class="method"><a class="src rightside" href="../src/core/num/f128.rs.html#1365-1368">Source</a><h4 class="code-header">pub const fn <a href="#method.copysign" class="fn">copysign</a>(self, sign: <a class="primitive" href="primitive.f128.html">f128</a>) -&gt; <a class="primitive" href="primitive.f128.html">f128</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>f128</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/116909">#116909</a>)</span></div></span></summary><div class="docblock"><p>Returns a number composed of the magnitude of <code>self</code> and the sign of
<code>sign</code>.</p>
<p>Equal to <code>self</code> if the sign of <code>self</code> and <code>sign</code> are the same, otherwise equal to <code>-self</code>.
If <code>self</code> is a NaN, then a NaN with the same payload as <code>self</code> and the sign bit of <code>sign</code> is
returned.</p>
<p>If <code>sign</code> is a NaN, then this operation will still carry over its sign into the result. Note
that IEEE 754 doesn’t assign any meaning to the sign bit in case of a NaN, and as Rust
doesn’t guarantee that the bit pattern of NaNs are conserved over arithmetic operations, the
result of <code>copysign</code> with <code>sign</code> being a NaN might produce an unexpected or non-portable
result. See the <a href="primitive.f32.html#nan-bit-patterns" title="primitive f32">specification of NaN bit patterns</a> for more
info.</p>
<h5 id="examples-10"><a class="doc-anchor" href="#examples-10">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(f128)]

</span><span class="kw">let </span>f = <span class="number">3.5_f128</span>;

<span class="macro">assert_eq!</span>(f.copysign(<span class="number">0.42</span>), <span class="number">3.5_f128</span>);
<span class="macro">assert_eq!</span>(f.copysign(-<span class="number">0.42</span>), -<span class="number">3.5_f128</span>);
<span class="macro">assert_eq!</span>((-f).copysign(<span class="number">0.42</span>), <span class="number">3.5_f128</span>);
<span class="macro">assert_eq!</span>((-f).copysign(-<span class="number">0.42</span>), -<span class="number">3.5_f128</span>);

<span class="macro">assert!</span>(f128::NAN.copysign(<span class="number">1.0</span>).is_nan());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(f128)%5D%0Afn+main()+%7B%0A++++%23%5Bcfg(all(target_arch+=+%22x86_64%22,+target_os+=+%22linux%22))%5D+%7B%0A++++%0A++++let+f+=+3.5_f128;%0A++++%0A++++assert_eq!(f.copysign(0.42),+3.5_f128);%0A++++assert_eq!(f.copysign(-0.42),+-3.5_f128);%0A++++assert_eq!((-f).copysign(0.42),+3.5_f128);%0A++++assert_eq!((-f).copysign(-0.42),+-3.5_f128);%0A++++%0A++++assert!(f128::NAN.copysign(1.0).is_nan());%0A++++%7D%0A%7D&amp;version=nightly&amp;edition=2021"></a></div>
</div></details></div></details></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Add%3C%26f128%3E-for-%26f128" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="../src/core/ops/arith.rs.html#110">Source</a></span><a href="#impl-Add%3C%26f128%3E-for-%26f128" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="ops/trait.Add.html" title="trait core::ops::Add">Add</a>&lt;&amp;<a class="primitive" href="primitive.f128.html">f128</a>&gt; for &amp;<a class="primitive" href="primitive.f128.html">f128</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-3" class="associatedtype trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#110">Source</a><a href="#associatedtype.Output-3" class="anchor">§</a><h4 class="code-header">type <a href="ops/trait.Add.html#associatedtype.Output" class="associatedtype">Output</a> = &lt;<a class="primitive" href="primitive.f128.html">f128</a> as <a class="trait" href="ops/trait.Add.html" title="trait core::ops::Add">Add</a>&gt;::<a class="associatedtype" href="ops/trait.Add.html#associatedtype.Output" title="type core::ops::Add::Output">Output</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>+</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.add-3" class="method trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#110">Source</a><a href="#method.add-3" class="anchor">§</a><h4 class="code-header">fn <a href="ops/trait.Add.html#tymethod.add" class="fn">add</a>(self, other: &amp;<a class="primitive" href="primitive.f128.html">f128</a>) -&gt; &lt;<a class="primitive" href="primitive.f128.html">f128</a> as <a class="trait" href="ops/trait.Add.html" title="trait core::ops::Add">Add</a>&lt;<a class="primitive" href="primitive.f128.html">f128</a>&gt;&gt;::<a class="associatedtype" href="ops/trait.Add.html#associatedtype.Output" title="type core::ops::Add::Output">Output</a></h4></section></summary><div class='docblock'>Performs the <code>+</code> operation. <a href="ops/trait.Add.html#tymethod.add">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Add%3C%26f128%3E-for-f128" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="../src/core/ops/arith.rs.html#110">Source</a></span><a href="#impl-Add%3C%26f128%3E-for-f128" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="ops/trait.Add.html" title="trait core::ops::Add">Add</a>&lt;&amp;<a class="primitive" href="primitive.f128.html">f128</a>&gt; for <a class="primitive" href="primitive.f128.html">f128</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-2" class="associatedtype trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#110">Source</a><a href="#associatedtype.Output-2" class="anchor">§</a><h4 class="code-header">type <a href="ops/trait.Add.html#associatedtype.Output" class="associatedtype">Output</a> = &lt;<a class="primitive" href="primitive.f128.html">f128</a> as <a class="trait" href="ops/trait.Add.html" title="trait core::ops::Add">Add</a>&gt;::<a class="associatedtype" href="ops/trait.Add.html#associatedtype.Output" title="type core::ops::Add::Output">Output</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>+</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.add-2" class="method trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#110">Source</a><a href="#method.add-2" class="anchor">§</a><h4 class="code-header">fn <a href="ops/trait.Add.html#tymethod.add" class="fn">add</a>(self, other: &amp;<a class="primitive" href="primitive.f128.html">f128</a>) -&gt; &lt;<a class="primitive" href="primitive.f128.html">f128</a> as <a class="trait" href="ops/trait.Add.html" title="trait core::ops::Add">Add</a>&lt;<a class="primitive" href="primitive.f128.html">f128</a>&gt;&gt;::<a class="associatedtype" href="ops/trait.Add.html#associatedtype.Output" title="type core::ops::Add::Output">Output</a></h4></section></summary><div class='docblock'>Performs the <code>+</code> operation. <a href="ops/trait.Add.html#tymethod.add">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Add%3Cf128%3E-for-%26f128" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="../src/core/ops/arith.rs.html#110">Source</a></span><a href="#impl-Add%3Cf128%3E-for-%26f128" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="ops/trait.Add.html" title="trait core::ops::Add">Add</a>&lt;<a class="primitive" href="primitive.f128.html">f128</a>&gt; for &amp;'a <a class="primitive" href="primitive.f128.html">f128</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-1" class="associatedtype trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#110">Source</a><a href="#associatedtype.Output-1" class="anchor">§</a><h4 class="code-header">type <a href="ops/trait.Add.html#associatedtype.Output" class="associatedtype">Output</a> = &lt;<a class="primitive" href="primitive.f128.html">f128</a> as <a class="trait" href="ops/trait.Add.html" title="trait core::ops::Add">Add</a>&gt;::<a class="associatedtype" href="ops/trait.Add.html#associatedtype.Output" title="type core::ops::Add::Output">Output</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>+</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.add-1" class="method trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#110">Source</a><a href="#method.add-1" class="anchor">§</a><h4 class="code-header">fn <a href="ops/trait.Add.html#tymethod.add" class="fn">add</a>(self, other: <a class="primitive" href="primitive.f128.html">f128</a>) -&gt; &lt;<a class="primitive" href="primitive.f128.html">f128</a> as <a class="trait" href="ops/trait.Add.html" title="trait core::ops::Add">Add</a>&lt;<a class="primitive" href="primitive.f128.html">f128</a>&gt;&gt;::<a class="associatedtype" href="ops/trait.Add.html#associatedtype.Output" title="type core::ops::Add::Output">Output</a></h4></section></summary><div class='docblock'>Performs the <code>+</code> operation. <a href="ops/trait.Add.html#tymethod.add">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Add-for-f128" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="../src/core/ops/arith.rs.html#110">Source</a></span><a href="#impl-Add-for-f128" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="ops/trait.Add.html" title="trait core::ops::Add">Add</a> for <a class="primitive" href="primitive.f128.html">f128</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output" class="associatedtype trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#110">Source</a><a href="#associatedtype.Output" class="anchor">§</a><h4 class="code-header">type <a href="ops/trait.Add.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="primitive" href="primitive.f128.html">f128</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>+</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.add" class="method trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#110">Source</a><a href="#method.add" class="anchor">§</a><h4 class="code-header">fn <a href="ops/trait.Add.html#tymethod.add" class="fn">add</a>(self, other: <a class="primitive" href="primitive.f128.html">f128</a>) -&gt; <a class="primitive" href="primitive.f128.html">f128</a></h4></section></summary><div class='docblock'>Performs the <code>+</code> operation. <a href="ops/trait.Add.html#tymethod.add">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-AddAssign%3C%26f128%3E-for-f128" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.22.0">1.22.0</span> · <a class="src" href="../src/core/ops/arith.rs.html#766">Source</a></span><a href="#impl-AddAssign%3C%26f128%3E-for-f128" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="ops/trait.AddAssign.html" title="trait core::ops::AddAssign">AddAssign</a>&lt;&amp;<a class="primitive" href="primitive.f128.html">f128</a>&gt; for <a class="primitive" href="primitive.f128.html">f128</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.add_assign-1" class="method trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#766">Source</a><a href="#method.add_assign-1" class="anchor">§</a><h4 class="code-header">fn <a href="ops/trait.AddAssign.html#tymethod.add_assign" class="fn">add_assign</a>(&amp;mut self, other: &amp;<a class="primitive" href="primitive.f128.html">f128</a>)</h4></section></summary><div class='docblock'>Performs the <code>+=</code> operation. <a href="ops/trait.AddAssign.html#tymethod.add_assign">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-AddAssign-for-f128" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.8.0">1.8.0</span> · <a class="src" href="../src/core/ops/arith.rs.html#766">Source</a></span><a href="#impl-AddAssign-for-f128" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="ops/trait.AddAssign.html" title="trait core::ops::AddAssign">AddAssign</a> for <a class="primitive" href="primitive.f128.html">f128</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.add_assign" class="method trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#766">Source</a><a href="#method.add_assign" class="anchor">§</a><h4 class="code-header">fn <a href="ops/trait.AddAssign.html#tymethod.add_assign" class="fn">add_assign</a>(&amp;mut self, other: <a class="primitive" href="primitive.f128.html">f128</a>)</h4></section></summary><div class='docblock'>Performs the <code>+=</code> operation. <a href="ops/trait.AddAssign.html#tymethod.add_assign">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Clone-for-f128" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="../src/core/clone.rs.html#334-339">Source</a></span><a href="#impl-Clone-for-f128" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="primitive" href="primitive.f128.html">f128</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone" class="method trait-impl"><a class="src rightside" href="../src/core/clone.rs.html#334-339">Source</a><a href="#method.clone" class="anchor">§</a><h4 class="code-header">fn <a href="clone/trait.Clone.html#tymethod.clone" class="fn">clone</a>(&amp;self) -&gt; Self</h4></section></summary><div class='docblock'>Returns a copy of the value. <a href="clone/trait.Clone.html#tymethod.clone">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_from" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="../src/core/clone.rs.html#174-176">Source</a></span><a href="#method.clone_from" class="anchor">§</a><h4 class="code-header">fn <a href="clone/trait.Clone.html#method.clone_from" class="fn">clone_from</a>(&amp;mut self, source: &amp;Self)</h4></section></summary><div class='docblock'>Performs copy-assignment from <code>source</code>. <a href="clone/trait.Clone.html#method.clone_from">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-f128" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="../src/core/fmt/float.rs.html#243-248">Source</a></span><a href="#impl-Debug-for-f128" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="primitive" href="primitive.f128.html">f128</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a class="src rightside" href="../src/core/fmt/float.rs.html#245-247">Source</a><a href="#method.fmt" class="anchor">§</a><h4 class="code-header">fn <a href="fmt/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Default-for-f128" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="../src/core/default.rs.html#185">Source</a></span><a href="#impl-Default-for-f128" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="default/trait.Default.html" title="trait core::default::Default">Default</a> for <a class="primitive" href="primitive.f128.html">f128</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.default" class="method trait-impl"><a class="src rightside" href="../src/core/default.rs.html#185">Source</a><a href="#method.default" class="anchor">§</a><h4 class="code-header">fn <a href="default/trait.Default.html#tymethod.default" class="fn">default</a>() -&gt; <a class="primitive" href="primitive.f128.html">f128</a></h4></section></summary><div class="docblock"><p>Returns the default value of <code>0.0</code></p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Div%3C%26f128%3E-for-%26f128" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="../src/core/ops/arith.rs.html#507">Source</a></span><a href="#impl-Div%3C%26f128%3E-for-%26f128" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="ops/trait.Div.html" title="trait core::ops::Div">Div</a>&lt;&amp;<a class="primitive" href="primitive.f128.html">f128</a>&gt; for &amp;<a class="primitive" href="primitive.f128.html">f128</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-15" class="associatedtype trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#507">Source</a><a href="#associatedtype.Output-15" class="anchor">§</a><h4 class="code-header">type <a href="ops/trait.Div.html#associatedtype.Output" class="associatedtype">Output</a> = &lt;<a class="primitive" href="primitive.f128.html">f128</a> as <a class="trait" href="ops/trait.Div.html" title="trait core::ops::Div">Div</a>&gt;::<a class="associatedtype" href="ops/trait.Div.html#associatedtype.Output" title="type core::ops::Div::Output">Output</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>/</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.div-3" class="method trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#507">Source</a><a href="#method.div-3" class="anchor">§</a><h4 class="code-header">fn <a href="ops/trait.Div.html#tymethod.div" class="fn">div</a>(self, other: &amp;<a class="primitive" href="primitive.f128.html">f128</a>) -&gt; &lt;<a class="primitive" href="primitive.f128.html">f128</a> as <a class="trait" href="ops/trait.Div.html" title="trait core::ops::Div">Div</a>&lt;<a class="primitive" href="primitive.f128.html">f128</a>&gt;&gt;::<a class="associatedtype" href="ops/trait.Div.html#associatedtype.Output" title="type core::ops::Div::Output">Output</a></h4></section></summary><div class='docblock'>Performs the <code>/</code> operation. <a href="ops/trait.Div.html#tymethod.div">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Div%3C%26f128%3E-for-f128" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="../src/core/ops/arith.rs.html#507">Source</a></span><a href="#impl-Div%3C%26f128%3E-for-f128" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="ops/trait.Div.html" title="trait core::ops::Div">Div</a>&lt;&amp;<a class="primitive" href="primitive.f128.html">f128</a>&gt; for <a class="primitive" href="primitive.f128.html">f128</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-14" class="associatedtype trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#507">Source</a><a href="#associatedtype.Output-14" class="anchor">§</a><h4 class="code-header">type <a href="ops/trait.Div.html#associatedtype.Output" class="associatedtype">Output</a> = &lt;<a class="primitive" href="primitive.f128.html">f128</a> as <a class="trait" href="ops/trait.Div.html" title="trait core::ops::Div">Div</a>&gt;::<a class="associatedtype" href="ops/trait.Div.html#associatedtype.Output" title="type core::ops::Div::Output">Output</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>/</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.div-2" class="method trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#507">Source</a><a href="#method.div-2" class="anchor">§</a><h4 class="code-header">fn <a href="ops/trait.Div.html#tymethod.div" class="fn">div</a>(self, other: &amp;<a class="primitive" href="primitive.f128.html">f128</a>) -&gt; &lt;<a class="primitive" href="primitive.f128.html">f128</a> as <a class="trait" href="ops/trait.Div.html" title="trait core::ops::Div">Div</a>&lt;<a class="primitive" href="primitive.f128.html">f128</a>&gt;&gt;::<a class="associatedtype" href="ops/trait.Div.html#associatedtype.Output" title="type core::ops::Div::Output">Output</a></h4></section></summary><div class='docblock'>Performs the <code>/</code> operation. <a href="ops/trait.Div.html#tymethod.div">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Div%3Cf128%3E-for-%26f128" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="../src/core/ops/arith.rs.html#507">Source</a></span><a href="#impl-Div%3Cf128%3E-for-%26f128" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="ops/trait.Div.html" title="trait core::ops::Div">Div</a>&lt;<a class="primitive" href="primitive.f128.html">f128</a>&gt; for &amp;'a <a class="primitive" href="primitive.f128.html">f128</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-13" class="associatedtype trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#507">Source</a><a href="#associatedtype.Output-13" class="anchor">§</a><h4 class="code-header">type <a href="ops/trait.Div.html#associatedtype.Output" class="associatedtype">Output</a> = &lt;<a class="primitive" href="primitive.f128.html">f128</a> as <a class="trait" href="ops/trait.Div.html" title="trait core::ops::Div">Div</a>&gt;::<a class="associatedtype" href="ops/trait.Div.html#associatedtype.Output" title="type core::ops::Div::Output">Output</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>/</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.div-1" class="method trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#507">Source</a><a href="#method.div-1" class="anchor">§</a><h4 class="code-header">fn <a href="ops/trait.Div.html#tymethod.div" class="fn">div</a>(self, other: <a class="primitive" href="primitive.f128.html">f128</a>) -&gt; &lt;<a class="primitive" href="primitive.f128.html">f128</a> as <a class="trait" href="ops/trait.Div.html" title="trait core::ops::Div">Div</a>&lt;<a class="primitive" href="primitive.f128.html">f128</a>&gt;&gt;::<a class="associatedtype" href="ops/trait.Div.html#associatedtype.Output" title="type core::ops::Div::Output">Output</a></h4></section></summary><div class='docblock'>Performs the <code>/</code> operation. <a href="ops/trait.Div.html#tymethod.div">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Div-for-f128" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="../src/core/ops/arith.rs.html#507">Source</a></span><a href="#impl-Div-for-f128" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="ops/trait.Div.html" title="trait core::ops::Div">Div</a> for <a class="primitive" href="primitive.f128.html">f128</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-12" class="associatedtype trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#507">Source</a><a href="#associatedtype.Output-12" class="anchor">§</a><h4 class="code-header">type <a href="ops/trait.Div.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="primitive" href="primitive.f128.html">f128</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>/</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.div" class="method trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#507">Source</a><a href="#method.div" class="anchor">§</a><h4 class="code-header">fn <a href="ops/trait.Div.html#tymethod.div" class="fn">div</a>(self, other: <a class="primitive" href="primitive.f128.html">f128</a>) -&gt; <a class="primitive" href="primitive.f128.html">f128</a></h4></section></summary><div class='docblock'>Performs the <code>/</code> operation. <a href="ops/trait.Div.html#tymethod.div">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-DivAssign%3C%26f128%3E-for-f128" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.22.0">1.22.0</span> · <a class="src" href="../src/core/ops/arith.rs.html#948">Source</a></span><a href="#impl-DivAssign%3C%26f128%3E-for-f128" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="ops/trait.DivAssign.html" title="trait core::ops::DivAssign">DivAssign</a>&lt;&amp;<a class="primitive" href="primitive.f128.html">f128</a>&gt; for <a class="primitive" href="primitive.f128.html">f128</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.div_assign-1" class="method trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#948">Source</a><a href="#method.div_assign-1" class="anchor">§</a><h4 class="code-header">fn <a href="ops/trait.DivAssign.html#tymethod.div_assign" class="fn">div_assign</a>(&amp;mut self, other: &amp;<a class="primitive" href="primitive.f128.html">f128</a>)</h4></section></summary><div class='docblock'>Performs the <code>/=</code> operation. <a href="ops/trait.DivAssign.html#tymethod.div_assign">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-DivAssign-for-f128" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.8.0">1.8.0</span> · <a class="src" href="../src/core/ops/arith.rs.html#948">Source</a></span><a href="#impl-DivAssign-for-f128" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="ops/trait.DivAssign.html" title="trait core::ops::DivAssign">DivAssign</a> for <a class="primitive" href="primitive.f128.html">f128</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.div_assign" class="method trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#948">Source</a><a href="#method.div_assign" class="anchor">§</a><h4 class="code-header">fn <a href="ops/trait.DivAssign.html#tymethod.div_assign" class="fn">div_assign</a>(&amp;mut self, other: <a class="primitive" href="primitive.f128.html">f128</a>)</h4></section></summary><div class='docblock'>Performs the <code>/=</code> operation. <a href="ops/trait.DivAssign.html#tymethod.div_assign">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3Cf16%3E-for-f128" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.6.0">1.6.0</span> · <a class="src" href="../src/core/convert/num.rs.html#171">Source</a></span><a href="#impl-From%3Cf16%3E-for-f128" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="primitive" href="primitive.f16.html">f16</a>&gt; for <a class="primitive" href="primitive.f128.html">f128</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="../src/core/convert/num.rs.html#171">Source</a><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="convert/trait.From.html#tymethod.from" class="fn">from</a>(small: <a class="primitive" href="primitive.f16.html">f16</a>) -&gt; Self</h4></section></summary><div class="docblock"><p>Converts <a href="primitive.f16.html" title="primitive f16"><code>f16</code></a> to <a href="primitive.f128.html" title="primitive f128"><code>f128</code></a> losslessly.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3Cf32%3E-for-f128" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.6.0">1.6.0</span> · <a class="src" href="../src/core/convert/num.rs.html#173">Source</a></span><a href="#impl-From%3Cf32%3E-for-f128" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="primitive" href="primitive.f32.html">f32</a>&gt; for <a class="primitive" href="primitive.f128.html">f128</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-1" class="method trait-impl"><a class="src rightside" href="../src/core/convert/num.rs.html#173">Source</a><a href="#method.from-1" class="anchor">§</a><h4 class="code-header">fn <a href="convert/trait.From.html#tymethod.from" class="fn">from</a>(small: <a class="primitive" href="primitive.f32.html">f32</a>) -&gt; Self</h4></section></summary><div class="docblock"><p>Converts <a href="primitive.f32.html" title="primitive f32"><code>f32</code></a> to <a href="primitive.f128.html" title="primitive f128"><code>f128</code></a> losslessly.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3Cf64%3E-for-f128" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.6.0">1.6.0</span> · <a class="src" href="../src/core/convert/num.rs.html#174">Source</a></span><a href="#impl-From%3Cf64%3E-for-f128" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="primitive" href="primitive.f64.html">f64</a>&gt; for <a class="primitive" href="primitive.f128.html">f128</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-2" class="method trait-impl"><a class="src rightside" href="../src/core/convert/num.rs.html#174">Source</a><a href="#method.from-2" class="anchor">§</a><h4 class="code-header">fn <a href="convert/trait.From.html#tymethod.from" class="fn">from</a>(small: <a class="primitive" href="primitive.f64.html">f64</a>) -&gt; Self</h4></section></summary><div class="docblock"><p>Converts <a href="primitive.f64.html" title="primitive f64"><code>f64</code></a> to <a href="primitive.f128.html" title="primitive f128"><code>f128</code></a> losslessly.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Mul%3C%26f128%3E-for-%26f128" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="../src/core/ops/arith.rs.html#349">Source</a></span><a href="#impl-Mul%3C%26f128%3E-for-%26f128" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="ops/trait.Mul.html" title="trait core::ops::Mul">Mul</a>&lt;&amp;<a class="primitive" href="primitive.f128.html">f128</a>&gt; for &amp;<a class="primitive" href="primitive.f128.html">f128</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-11" class="associatedtype trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#349">Source</a><a href="#associatedtype.Output-11" class="anchor">§</a><h4 class="code-header">type <a href="ops/trait.Mul.html#associatedtype.Output" class="associatedtype">Output</a> = &lt;<a class="primitive" href="primitive.f128.html">f128</a> as <a class="trait" href="ops/trait.Mul.html" title="trait core::ops::Mul">Mul</a>&gt;::<a class="associatedtype" href="ops/trait.Mul.html#associatedtype.Output" title="type core::ops::Mul::Output">Output</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>*</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.mul-3" class="method trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#349">Source</a><a href="#method.mul-3" class="anchor">§</a><h4 class="code-header">fn <a href="ops/trait.Mul.html#tymethod.mul" class="fn">mul</a>(self, other: &amp;<a class="primitive" href="primitive.f128.html">f128</a>) -&gt; &lt;<a class="primitive" href="primitive.f128.html">f128</a> as <a class="trait" href="ops/trait.Mul.html" title="trait core::ops::Mul">Mul</a>&lt;<a class="primitive" href="primitive.f128.html">f128</a>&gt;&gt;::<a class="associatedtype" href="ops/trait.Mul.html#associatedtype.Output" title="type core::ops::Mul::Output">Output</a></h4></section></summary><div class='docblock'>Performs the <code>*</code> operation. <a href="ops/trait.Mul.html#tymethod.mul">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Mul%3C%26f128%3E-for-f128" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="../src/core/ops/arith.rs.html#349">Source</a></span><a href="#impl-Mul%3C%26f128%3E-for-f128" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="ops/trait.Mul.html" title="trait core::ops::Mul">Mul</a>&lt;&amp;<a class="primitive" href="primitive.f128.html">f128</a>&gt; for <a class="primitive" href="primitive.f128.html">f128</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-10" class="associatedtype trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#349">Source</a><a href="#associatedtype.Output-10" class="anchor">§</a><h4 class="code-header">type <a href="ops/trait.Mul.html#associatedtype.Output" class="associatedtype">Output</a> = &lt;<a class="primitive" href="primitive.f128.html">f128</a> as <a class="trait" href="ops/trait.Mul.html" title="trait core::ops::Mul">Mul</a>&gt;::<a class="associatedtype" href="ops/trait.Mul.html#associatedtype.Output" title="type core::ops::Mul::Output">Output</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>*</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.mul-2" class="method trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#349">Source</a><a href="#method.mul-2" class="anchor">§</a><h4 class="code-header">fn <a href="ops/trait.Mul.html#tymethod.mul" class="fn">mul</a>(self, other: &amp;<a class="primitive" href="primitive.f128.html">f128</a>) -&gt; &lt;<a class="primitive" href="primitive.f128.html">f128</a> as <a class="trait" href="ops/trait.Mul.html" title="trait core::ops::Mul">Mul</a>&lt;<a class="primitive" href="primitive.f128.html">f128</a>&gt;&gt;::<a class="associatedtype" href="ops/trait.Mul.html#associatedtype.Output" title="type core::ops::Mul::Output">Output</a></h4></section></summary><div class='docblock'>Performs the <code>*</code> operation. <a href="ops/trait.Mul.html#tymethod.mul">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Mul%3Cf128%3E-for-%26f128" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="../src/core/ops/arith.rs.html#349">Source</a></span><a href="#impl-Mul%3Cf128%3E-for-%26f128" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="ops/trait.Mul.html" title="trait core::ops::Mul">Mul</a>&lt;<a class="primitive" href="primitive.f128.html">f128</a>&gt; for &amp;'a <a class="primitive" href="primitive.f128.html">f128</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-9" class="associatedtype trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#349">Source</a><a href="#associatedtype.Output-9" class="anchor">§</a><h4 class="code-header">type <a href="ops/trait.Mul.html#associatedtype.Output" class="associatedtype">Output</a> = &lt;<a class="primitive" href="primitive.f128.html">f128</a> as <a class="trait" href="ops/trait.Mul.html" title="trait core::ops::Mul">Mul</a>&gt;::<a class="associatedtype" href="ops/trait.Mul.html#associatedtype.Output" title="type core::ops::Mul::Output">Output</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>*</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.mul-1" class="method trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#349">Source</a><a href="#method.mul-1" class="anchor">§</a><h4 class="code-header">fn <a href="ops/trait.Mul.html#tymethod.mul" class="fn">mul</a>(self, other: <a class="primitive" href="primitive.f128.html">f128</a>) -&gt; &lt;<a class="primitive" href="primitive.f128.html">f128</a> as <a class="trait" href="ops/trait.Mul.html" title="trait core::ops::Mul">Mul</a>&lt;<a class="primitive" href="primitive.f128.html">f128</a>&gt;&gt;::<a class="associatedtype" href="ops/trait.Mul.html#associatedtype.Output" title="type core::ops::Mul::Output">Output</a></h4></section></summary><div class='docblock'>Performs the <code>*</code> operation. <a href="ops/trait.Mul.html#tymethod.mul">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Mul-for-f128" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="../src/core/ops/arith.rs.html#349">Source</a></span><a href="#impl-Mul-for-f128" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="ops/trait.Mul.html" title="trait core::ops::Mul">Mul</a> for <a class="primitive" href="primitive.f128.html">f128</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-8" class="associatedtype trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#349">Source</a><a href="#associatedtype.Output-8" class="anchor">§</a><h4 class="code-header">type <a href="ops/trait.Mul.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="primitive" href="primitive.f128.html">f128</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>*</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.mul" class="method trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#349">Source</a><a href="#method.mul" class="anchor">§</a><h4 class="code-header">fn <a href="ops/trait.Mul.html#tymethod.mul" class="fn">mul</a>(self, other: <a class="primitive" href="primitive.f128.html">f128</a>) -&gt; <a class="primitive" href="primitive.f128.html">f128</a></h4></section></summary><div class='docblock'>Performs the <code>*</code> operation. <a href="ops/trait.Mul.html#tymethod.mul">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-MulAssign%3C%26f128%3E-for-f128" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.22.0">1.22.0</span> · <a class="src" href="../src/core/ops/arith.rs.html#891">Source</a></span><a href="#impl-MulAssign%3C%26f128%3E-for-f128" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="ops/trait.MulAssign.html" title="trait core::ops::MulAssign">MulAssign</a>&lt;&amp;<a class="primitive" href="primitive.f128.html">f128</a>&gt; for <a class="primitive" href="primitive.f128.html">f128</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.mul_assign-1" class="method trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#891">Source</a><a href="#method.mul_assign-1" class="anchor">§</a><h4 class="code-header">fn <a href="ops/trait.MulAssign.html#tymethod.mul_assign" class="fn">mul_assign</a>(&amp;mut self, other: &amp;<a class="primitive" href="primitive.f128.html">f128</a>)</h4></section></summary><div class='docblock'>Performs the <code>*=</code> operation. <a href="ops/trait.MulAssign.html#tymethod.mul_assign">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-MulAssign-for-f128" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.8.0">1.8.0</span> · <a class="src" href="../src/core/ops/arith.rs.html#891">Source</a></span><a href="#impl-MulAssign-for-f128" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="ops/trait.MulAssign.html" title="trait core::ops::MulAssign">MulAssign</a> for <a class="primitive" href="primitive.f128.html">f128</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.mul_assign" class="method trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#891">Source</a><a href="#method.mul_assign" class="anchor">§</a><h4 class="code-header">fn <a href="ops/trait.MulAssign.html#tymethod.mul_assign" class="fn">mul_assign</a>(&amp;mut self, other: <a class="primitive" href="primitive.f128.html">f128</a>)</h4></section></summary><div class='docblock'>Performs the <code>*=</code> operation. <a href="ops/trait.MulAssign.html#tymethod.mul_assign">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Neg-for-%26f128" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="../src/core/ops/arith.rs.html#699">Source</a></span><a href="#impl-Neg-for-%26f128" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="ops/trait.Neg.html" title="trait core::ops::Neg">Neg</a> for &amp;<a class="primitive" href="primitive.f128.html">f128</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-21" class="associatedtype trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#699">Source</a><a href="#associatedtype.Output-21" class="anchor">§</a><h4 class="code-header">type <a href="ops/trait.Neg.html#associatedtype.Output" class="associatedtype">Output</a> = &lt;<a class="primitive" href="primitive.f128.html">f128</a> as <a class="trait" href="ops/trait.Neg.html" title="trait core::ops::Neg">Neg</a>&gt;::<a class="associatedtype" href="ops/trait.Neg.html#associatedtype.Output" title="type core::ops::Neg::Output">Output</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>-</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.neg-1" class="method trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#699">Source</a><a href="#method.neg-1" class="anchor">§</a><h4 class="code-header">fn <a href="ops/trait.Neg.html#tymethod.neg" class="fn">neg</a>(self) -&gt; &lt;<a class="primitive" href="primitive.f128.html">f128</a> as <a class="trait" href="ops/trait.Neg.html" title="trait core::ops::Neg">Neg</a>&gt;::<a class="associatedtype" href="ops/trait.Neg.html#associatedtype.Output" title="type core::ops::Neg::Output">Output</a></h4></section></summary><div class='docblock'>Performs the unary <code>-</code> operation. <a href="ops/trait.Neg.html#tymethod.neg">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Neg-for-f128" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="../src/core/ops/arith.rs.html#699">Source</a></span><a href="#impl-Neg-for-f128" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="ops/trait.Neg.html" title="trait core::ops::Neg">Neg</a> for <a class="primitive" href="primitive.f128.html">f128</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-20" class="associatedtype trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#699">Source</a><a href="#associatedtype.Output-20" class="anchor">§</a><h4 class="code-header">type <a href="ops/trait.Neg.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="primitive" href="primitive.f128.html">f128</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>-</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.neg" class="method trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#699">Source</a><a href="#method.neg" class="anchor">§</a><h4 class="code-header">fn <a href="ops/trait.Neg.html#tymethod.neg" class="fn">neg</a>(self) -&gt; <a class="primitive" href="primitive.f128.html">f128</a></h4></section></summary><div class='docblock'>Performs the unary <code>-</code> operation. <a href="ops/trait.Neg.html#tymethod.neg">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialEq-for-f128" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="../src/core/cmp.rs.html#1655-1657">Source</a></span><a href="#impl-PartialEq-for-f128" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a> for <a class="primitive" href="primitive.f128.html">f128</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.eq" class="method trait-impl"><a class="src rightside" href="../src/core/cmp.rs.html#1655-1657">Source</a><a href="#method.eq" class="anchor">§</a><h4 class="code-header">fn <a href="cmp/trait.PartialEq.html#tymethod.eq" class="fn">eq</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.f128.html">f128</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.ne" class="method trait-impl"><a class="src rightside" href="../src/core/cmp.rs.html#1655-1657">Source</a><a href="#method.ne" class="anchor">§</a><h4 class="code-header">fn <a href="cmp/trait.PartialEq.html#method.ne" class="fn">ne</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.f128.html">f128</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>!=</code>. The default implementation is almost always sufficient,
and should not be overridden without very good reason.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialOrd-for-f128" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="../src/core/cmp.rs.html#1709">Source</a></span><a href="#impl-PartialOrd-for-f128" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a> for <a class="primitive" href="primitive.f128.html">f128</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.partial_cmp" class="method trait-impl"><a class="src rightside" href="../src/core/cmp.rs.html#1709">Source</a><a href="#method.partial_cmp" class="anchor">§</a><h4 class="code-header">fn <a href="cmp/trait.PartialOrd.html#tymethod.partial_cmp" class="fn">partial_cmp</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.f128.html">f128</a>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a>&gt;</h4></section></summary><div class='docblock'>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="cmp/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.lt" class="method trait-impl"><a class="src rightside" href="../src/core/cmp.rs.html#1709">Source</a><a href="#method.lt" class="anchor">§</a><h4 class="code-header">fn <a href="cmp/trait.PartialOrd.html#method.lt" class="fn">lt</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.f128.html">f128</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="cmp/trait.PartialOrd.html#method.lt">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.le" class="method trait-impl"><a class="src rightside" href="../src/core/cmp.rs.html#1709">Source</a><a href="#method.le" class="anchor">§</a><h4 class="code-header">fn <a href="cmp/trait.PartialOrd.html#method.le" class="fn">le</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.f128.html">f128</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the
<code>&lt;=</code> operator. <a href="cmp/trait.PartialOrd.html#method.le">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.ge" class="method trait-impl"><a class="src rightside" href="../src/core/cmp.rs.html#1709">Source</a><a href="#method.ge" class="anchor">§</a><h4 class="code-header">fn <a href="cmp/trait.PartialOrd.html#method.ge" class="fn">ge</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.f128.html">f128</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by
the <code>&gt;=</code> operator. <a href="cmp/trait.PartialOrd.html#method.ge">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.gt" class="method trait-impl"><a class="src rightside" href="../src/core/cmp.rs.html#1709">Source</a><a href="#method.gt" class="anchor">§</a><h4 class="code-header">fn <a href="cmp/trait.PartialOrd.html#method.gt" class="fn">gt</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.f128.html">f128</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code>
operator. <a href="cmp/trait.PartialOrd.html#method.gt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Rem%3C%26f128%3E-for-%26f128" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="../src/core/ops/arith.rs.html#624">Source</a></span><a href="#impl-Rem%3C%26f128%3E-for-%26f128" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="ops/trait.Rem.html" title="trait core::ops::Rem">Rem</a>&lt;&amp;<a class="primitive" href="primitive.f128.html">f128</a>&gt; for &amp;<a class="primitive" href="primitive.f128.html">f128</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-19" class="associatedtype trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#624">Source</a><a href="#associatedtype.Output-19" class="anchor">§</a><h4 class="code-header">type <a href="ops/trait.Rem.html#associatedtype.Output" class="associatedtype">Output</a> = &lt;<a class="primitive" href="primitive.f128.html">f128</a> as <a class="trait" href="ops/trait.Rem.html" title="trait core::ops::Rem">Rem</a>&gt;::<a class="associatedtype" href="ops/trait.Rem.html#associatedtype.Output" title="type core::ops::Rem::Output">Output</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>%</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.rem-3" class="method trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#624">Source</a><a href="#method.rem-3" class="anchor">§</a><h4 class="code-header">fn <a href="ops/trait.Rem.html#tymethod.rem" class="fn">rem</a>(self, other: &amp;<a class="primitive" href="primitive.f128.html">f128</a>) -&gt; &lt;<a class="primitive" href="primitive.f128.html">f128</a> as <a class="trait" href="ops/trait.Rem.html" title="trait core::ops::Rem">Rem</a>&lt;<a class="primitive" href="primitive.f128.html">f128</a>&gt;&gt;::<a class="associatedtype" href="ops/trait.Rem.html#associatedtype.Output" title="type core::ops::Rem::Output">Output</a></h4></section></summary><div class='docblock'>Performs the <code>%</code> operation. <a href="ops/trait.Rem.html#tymethod.rem">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Rem%3C%26f128%3E-for-f128" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="../src/core/ops/arith.rs.html#624">Source</a></span><a href="#impl-Rem%3C%26f128%3E-for-f128" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="ops/trait.Rem.html" title="trait core::ops::Rem">Rem</a>&lt;&amp;<a class="primitive" href="primitive.f128.html">f128</a>&gt; for <a class="primitive" href="primitive.f128.html">f128</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-18" class="associatedtype trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#624">Source</a><a href="#associatedtype.Output-18" class="anchor">§</a><h4 class="code-header">type <a href="ops/trait.Rem.html#associatedtype.Output" class="associatedtype">Output</a> = &lt;<a class="primitive" href="primitive.f128.html">f128</a> as <a class="trait" href="ops/trait.Rem.html" title="trait core::ops::Rem">Rem</a>&gt;::<a class="associatedtype" href="ops/trait.Rem.html#associatedtype.Output" title="type core::ops::Rem::Output">Output</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>%</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.rem-2" class="method trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#624">Source</a><a href="#method.rem-2" class="anchor">§</a><h4 class="code-header">fn <a href="ops/trait.Rem.html#tymethod.rem" class="fn">rem</a>(self, other: &amp;<a class="primitive" href="primitive.f128.html">f128</a>) -&gt; &lt;<a class="primitive" href="primitive.f128.html">f128</a> as <a class="trait" href="ops/trait.Rem.html" title="trait core::ops::Rem">Rem</a>&lt;<a class="primitive" href="primitive.f128.html">f128</a>&gt;&gt;::<a class="associatedtype" href="ops/trait.Rem.html#associatedtype.Output" title="type core::ops::Rem::Output">Output</a></h4></section></summary><div class='docblock'>Performs the <code>%</code> operation. <a href="ops/trait.Rem.html#tymethod.rem">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Rem%3Cf128%3E-for-%26f128" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="../src/core/ops/arith.rs.html#624">Source</a></span><a href="#impl-Rem%3Cf128%3E-for-%26f128" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="ops/trait.Rem.html" title="trait core::ops::Rem">Rem</a>&lt;<a class="primitive" href="primitive.f128.html">f128</a>&gt; for &amp;'a <a class="primitive" href="primitive.f128.html">f128</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-17" class="associatedtype trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#624">Source</a><a href="#associatedtype.Output-17" class="anchor">§</a><h4 class="code-header">type <a href="ops/trait.Rem.html#associatedtype.Output" class="associatedtype">Output</a> = &lt;<a class="primitive" href="primitive.f128.html">f128</a> as <a class="trait" href="ops/trait.Rem.html" title="trait core::ops::Rem">Rem</a>&gt;::<a class="associatedtype" href="ops/trait.Rem.html#associatedtype.Output" title="type core::ops::Rem::Output">Output</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>%</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.rem-1" class="method trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#624">Source</a><a href="#method.rem-1" class="anchor">§</a><h4 class="code-header">fn <a href="ops/trait.Rem.html#tymethod.rem" class="fn">rem</a>(self, other: <a class="primitive" href="primitive.f128.html">f128</a>) -&gt; &lt;<a class="primitive" href="primitive.f128.html">f128</a> as <a class="trait" href="ops/trait.Rem.html" title="trait core::ops::Rem">Rem</a>&lt;<a class="primitive" href="primitive.f128.html">f128</a>&gt;&gt;::<a class="associatedtype" href="ops/trait.Rem.html#associatedtype.Output" title="type core::ops::Rem::Output">Output</a></h4></section></summary><div class='docblock'>Performs the <code>%</code> operation. <a href="ops/trait.Rem.html#tymethod.rem">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Rem-for-f128" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="../src/core/ops/arith.rs.html#624">Source</a></span><a href="#impl-Rem-for-f128" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="ops/trait.Rem.html" title="trait core::ops::Rem">Rem</a> for <a class="primitive" href="primitive.f128.html">f128</a></h3></section></summary><div class="docblock"><p>The remainder from the division of two floats.</p>
<p>The remainder has the same sign as the dividend and is computed as:
<code>x - (x / y).trunc() * y</code>.</p>
<h4 id="examples-11"><a class="doc-anchor" href="#examples-11">§</a>Examples</h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>x: f32 = <span class="number">50.50</span>;
<span class="kw">let </span>y: f32 = <span class="number">8.125</span>;
<span class="kw">let </span>remainder = x - (x / y).trunc() * y;

<span class="comment">// The answer to both operations is 1.75
</span><span class="macro">assert_eq!</span>(x % y, remainder);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+x:+f32+=+50.50;%0A++++let+y:+f32+=+8.125;%0A++++let+remainder+=+x+-+(x+/+y).trunc()+*+y;%0A++++%0A++++//+The+answer+to+both+operations+is+1.75%0A++++assert_eq!(x+%25+y,+remainder);%0A%7D&amp;edition=2021"></a></div>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-16" class="associatedtype trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#624">Source</a><a href="#associatedtype.Output-16" class="anchor">§</a><h4 class="code-header">type <a href="ops/trait.Rem.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="primitive" href="primitive.f128.html">f128</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>%</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.rem" class="method trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#624">Source</a><a href="#method.rem" class="anchor">§</a><h4 class="code-header">fn <a href="ops/trait.Rem.html#tymethod.rem" class="fn">rem</a>(self, other: <a class="primitive" href="primitive.f128.html">f128</a>) -&gt; <a class="primitive" href="primitive.f128.html">f128</a></h4></section></summary><div class='docblock'>Performs the <code>%</code> operation. <a href="ops/trait.Rem.html#tymethod.rem">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-RemAssign%3C%26f128%3E-for-f128" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.22.0">1.22.0</span> · <a class="src" href="../src/core/ops/arith.rs.html#1009">Source</a></span><a href="#impl-RemAssign%3C%26f128%3E-for-f128" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="ops/trait.RemAssign.html" title="trait core::ops::RemAssign">RemAssign</a>&lt;&amp;<a class="primitive" href="primitive.f128.html">f128</a>&gt; for <a class="primitive" href="primitive.f128.html">f128</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.rem_assign-1" class="method trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#1009">Source</a><a href="#method.rem_assign-1" class="anchor">§</a><h4 class="code-header">fn <a href="ops/trait.RemAssign.html#tymethod.rem_assign" class="fn">rem_assign</a>(&amp;mut self, other: &amp;<a class="primitive" href="primitive.f128.html">f128</a>)</h4></section></summary><div class='docblock'>Performs the <code>%=</code> operation. <a href="ops/trait.RemAssign.html#tymethod.rem_assign">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-RemAssign-for-f128" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.8.0">1.8.0</span> · <a class="src" href="../src/core/ops/arith.rs.html#1009">Source</a></span><a href="#impl-RemAssign-for-f128" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="ops/trait.RemAssign.html" title="trait core::ops::RemAssign">RemAssign</a> for <a class="primitive" href="primitive.f128.html">f128</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.rem_assign" class="method trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#1009">Source</a><a href="#method.rem_assign" class="anchor">§</a><h4 class="code-header">fn <a href="ops/trait.RemAssign.html#tymethod.rem_assign" class="fn">rem_assign</a>(&amp;mut self, other: <a class="primitive" href="primitive.f128.html">f128</a>)</h4></section></summary><div class='docblock'>Performs the <code>%=</code> operation. <a href="ops/trait.RemAssign.html#tymethod.rem_assign">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Sub%3C%26f128%3E-for-%26f128" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="../src/core/ops/arith.rs.html#219">Source</a></span><a href="#impl-Sub%3C%26f128%3E-for-%26f128" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="ops/trait.Sub.html" title="trait core::ops::Sub">Sub</a>&lt;&amp;<a class="primitive" href="primitive.f128.html">f128</a>&gt; for &amp;<a class="primitive" href="primitive.f128.html">f128</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-7" class="associatedtype trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#219">Source</a><a href="#associatedtype.Output-7" class="anchor">§</a><h4 class="code-header">type <a href="ops/trait.Sub.html#associatedtype.Output" class="associatedtype">Output</a> = &lt;<a class="primitive" href="primitive.f128.html">f128</a> as <a class="trait" href="ops/trait.Sub.html" title="trait core::ops::Sub">Sub</a>&gt;::<a class="associatedtype" href="ops/trait.Sub.html#associatedtype.Output" title="type core::ops::Sub::Output">Output</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>-</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.sub-3" class="method trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#219">Source</a><a href="#method.sub-3" class="anchor">§</a><h4 class="code-header">fn <a href="ops/trait.Sub.html#tymethod.sub" class="fn">sub</a>(self, other: &amp;<a class="primitive" href="primitive.f128.html">f128</a>) -&gt; &lt;<a class="primitive" href="primitive.f128.html">f128</a> as <a class="trait" href="ops/trait.Sub.html" title="trait core::ops::Sub">Sub</a>&lt;<a class="primitive" href="primitive.f128.html">f128</a>&gt;&gt;::<a class="associatedtype" href="ops/trait.Sub.html#associatedtype.Output" title="type core::ops::Sub::Output">Output</a></h4></section></summary><div class='docblock'>Performs the <code>-</code> operation. <a href="ops/trait.Sub.html#tymethod.sub">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Sub%3C%26f128%3E-for-f128" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="../src/core/ops/arith.rs.html#219">Source</a></span><a href="#impl-Sub%3C%26f128%3E-for-f128" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="ops/trait.Sub.html" title="trait core::ops::Sub">Sub</a>&lt;&amp;<a class="primitive" href="primitive.f128.html">f128</a>&gt; for <a class="primitive" href="primitive.f128.html">f128</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-6" class="associatedtype trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#219">Source</a><a href="#associatedtype.Output-6" class="anchor">§</a><h4 class="code-header">type <a href="ops/trait.Sub.html#associatedtype.Output" class="associatedtype">Output</a> = &lt;<a class="primitive" href="primitive.f128.html">f128</a> as <a class="trait" href="ops/trait.Sub.html" title="trait core::ops::Sub">Sub</a>&gt;::<a class="associatedtype" href="ops/trait.Sub.html#associatedtype.Output" title="type core::ops::Sub::Output">Output</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>-</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.sub-2" class="method trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#219">Source</a><a href="#method.sub-2" class="anchor">§</a><h4 class="code-header">fn <a href="ops/trait.Sub.html#tymethod.sub" class="fn">sub</a>(self, other: &amp;<a class="primitive" href="primitive.f128.html">f128</a>) -&gt; &lt;<a class="primitive" href="primitive.f128.html">f128</a> as <a class="trait" href="ops/trait.Sub.html" title="trait core::ops::Sub">Sub</a>&lt;<a class="primitive" href="primitive.f128.html">f128</a>&gt;&gt;::<a class="associatedtype" href="ops/trait.Sub.html#associatedtype.Output" title="type core::ops::Sub::Output">Output</a></h4></section></summary><div class='docblock'>Performs the <code>-</code> operation. <a href="ops/trait.Sub.html#tymethod.sub">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Sub%3Cf128%3E-for-%26f128" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="../src/core/ops/arith.rs.html#219">Source</a></span><a href="#impl-Sub%3Cf128%3E-for-%26f128" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="ops/trait.Sub.html" title="trait core::ops::Sub">Sub</a>&lt;<a class="primitive" href="primitive.f128.html">f128</a>&gt; for &amp;'a <a class="primitive" href="primitive.f128.html">f128</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-5" class="associatedtype trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#219">Source</a><a href="#associatedtype.Output-5" class="anchor">§</a><h4 class="code-header">type <a href="ops/trait.Sub.html#associatedtype.Output" class="associatedtype">Output</a> = &lt;<a class="primitive" href="primitive.f128.html">f128</a> as <a class="trait" href="ops/trait.Sub.html" title="trait core::ops::Sub">Sub</a>&gt;::<a class="associatedtype" href="ops/trait.Sub.html#associatedtype.Output" title="type core::ops::Sub::Output">Output</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>-</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.sub-1" class="method trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#219">Source</a><a href="#method.sub-1" class="anchor">§</a><h4 class="code-header">fn <a href="ops/trait.Sub.html#tymethod.sub" class="fn">sub</a>(self, other: <a class="primitive" href="primitive.f128.html">f128</a>) -&gt; &lt;<a class="primitive" href="primitive.f128.html">f128</a> as <a class="trait" href="ops/trait.Sub.html" title="trait core::ops::Sub">Sub</a>&lt;<a class="primitive" href="primitive.f128.html">f128</a>&gt;&gt;::<a class="associatedtype" href="ops/trait.Sub.html#associatedtype.Output" title="type core::ops::Sub::Output">Output</a></h4></section></summary><div class='docblock'>Performs the <code>-</code> operation. <a href="ops/trait.Sub.html#tymethod.sub">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Sub-for-f128" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="../src/core/ops/arith.rs.html#219">Source</a></span><a href="#impl-Sub-for-f128" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="ops/trait.Sub.html" title="trait core::ops::Sub">Sub</a> for <a class="primitive" href="primitive.f128.html">f128</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-4" class="associatedtype trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#219">Source</a><a href="#associatedtype.Output-4" class="anchor">§</a><h4 class="code-header">type <a href="ops/trait.Sub.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="primitive" href="primitive.f128.html">f128</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>-</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.sub" class="method trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#219">Source</a><a href="#method.sub" class="anchor">§</a><h4 class="code-header">fn <a href="ops/trait.Sub.html#tymethod.sub" class="fn">sub</a>(self, other: <a class="primitive" href="primitive.f128.html">f128</a>) -&gt; <a class="primitive" href="primitive.f128.html">f128</a></h4></section></summary><div class='docblock'>Performs the <code>-</code> operation. <a href="ops/trait.Sub.html#tymethod.sub">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-SubAssign%3C%26f128%3E-for-f128" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.22.0">1.22.0</span> · <a class="src" href="../src/core/ops/arith.rs.html#833">Source</a></span><a href="#impl-SubAssign%3C%26f128%3E-for-f128" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="ops/trait.SubAssign.html" title="trait core::ops::SubAssign">SubAssign</a>&lt;&amp;<a class="primitive" href="primitive.f128.html">f128</a>&gt; for <a class="primitive" href="primitive.f128.html">f128</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.sub_assign-1" class="method trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#833">Source</a><a href="#method.sub_assign-1" class="anchor">§</a><h4 class="code-header">fn <a href="ops/trait.SubAssign.html#tymethod.sub_assign" class="fn">sub_assign</a>(&amp;mut self, other: &amp;<a class="primitive" href="primitive.f128.html">f128</a>)</h4></section></summary><div class='docblock'>Performs the <code>-=</code> operation. <a href="ops/trait.SubAssign.html#tymethod.sub_assign">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-SubAssign-for-f128" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.8.0">1.8.0</span> · <a class="src" href="../src/core/ops/arith.rs.html#833">Source</a></span><a href="#impl-SubAssign-for-f128" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="ops/trait.SubAssign.html" title="trait core::ops::SubAssign">SubAssign</a> for <a class="primitive" href="primitive.f128.html">f128</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.sub_assign" class="method trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#833">Source</a><a href="#method.sub_assign" class="anchor">§</a><h4 class="code-header">fn <a href="ops/trait.SubAssign.html#tymethod.sub_assign" class="fn">sub_assign</a>(&amp;mut self, other: <a class="primitive" href="primitive.f128.html">f128</a>)</h4></section></summary><div class='docblock'>Performs the <code>-=</code> operation. <a href="ops/trait.SubAssign.html#tymethod.sub_assign">Read more</a></div></details></div></details><section id="impl-Copy-for-f128" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="../src/core/marker.rs.html#433-443">Source</a></span><a href="#impl-Copy-for-f128" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a> for <a class="primitive" href="primitive.f128.html">f128</a></h3></section><section id="impl-FloatToInt%3Ci128%3E-for-f128" class="impl"><a class="src rightside" href="../src/core/convert/num.rs.html#40">Source</a><a href="#impl-FloatToInt%3Ci128%3E-for-f128" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="convert/trait.FloatToInt.html" title="trait core::convert::FloatToInt">FloatToInt</a>&lt;<a class="primitive" href="primitive.i128.html">i128</a>&gt; for <a class="primitive" href="primitive.f128.html">f128</a></h3></section><section id="impl-FloatToInt%3Ci16%3E-for-f128" class="impl"><a class="src rightside" href="../src/core/convert/num.rs.html#40">Source</a><a href="#impl-FloatToInt%3Ci16%3E-for-f128" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="convert/trait.FloatToInt.html" title="trait core::convert::FloatToInt">FloatToInt</a>&lt;<a class="primitive" href="primitive.i16.html">i16</a>&gt; for <a class="primitive" href="primitive.f128.html">f128</a></h3></section><section id="impl-FloatToInt%3Ci32%3E-for-f128" class="impl"><a class="src rightside" href="../src/core/convert/num.rs.html#40">Source</a><a href="#impl-FloatToInt%3Ci32%3E-for-f128" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="convert/trait.FloatToInt.html" title="trait core::convert::FloatToInt">FloatToInt</a>&lt;<a class="primitive" href="primitive.i32.html">i32</a>&gt; for <a class="primitive" href="primitive.f128.html">f128</a></h3></section><section id="impl-FloatToInt%3Ci64%3E-for-f128" class="impl"><a class="src rightside" href="../src/core/convert/num.rs.html#40">Source</a><a href="#impl-FloatToInt%3Ci64%3E-for-f128" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="convert/trait.FloatToInt.html" title="trait core::convert::FloatToInt">FloatToInt</a>&lt;<a class="primitive" href="primitive.i64.html">i64</a>&gt; for <a class="primitive" href="primitive.f128.html">f128</a></h3></section><section id="impl-FloatToInt%3Ci8%3E-for-f128" class="impl"><a class="src rightside" href="../src/core/convert/num.rs.html#40">Source</a><a href="#impl-FloatToInt%3Ci8%3E-for-f128" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="convert/trait.FloatToInt.html" title="trait core::convert::FloatToInt">FloatToInt</a>&lt;<a class="primitive" href="primitive.i8.html">i8</a>&gt; for <a class="primitive" href="primitive.f128.html">f128</a></h3></section><section id="impl-FloatToInt%3Cisize%3E-for-f128" class="impl"><a class="src rightside" href="../src/core/convert/num.rs.html#40">Source</a><a href="#impl-FloatToInt%3Cisize%3E-for-f128" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="convert/trait.FloatToInt.html" title="trait core::convert::FloatToInt">FloatToInt</a>&lt;<a class="primitive" href="primitive.isize.html">isize</a>&gt; for <a class="primitive" href="primitive.f128.html">f128</a></h3></section><section id="impl-FloatToInt%3Cu128%3E-for-f128" class="impl"><a class="src rightside" href="../src/core/convert/num.rs.html#40">Source</a><a href="#impl-FloatToInt%3Cu128%3E-for-f128" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="convert/trait.FloatToInt.html" title="trait core::convert::FloatToInt">FloatToInt</a>&lt;<a class="primitive" href="primitive.u128.html">u128</a>&gt; for <a class="primitive" href="primitive.f128.html">f128</a></h3></section><section id="impl-FloatToInt%3Cu16%3E-for-f128" class="impl"><a class="src rightside" href="../src/core/convert/num.rs.html#40">Source</a><a href="#impl-FloatToInt%3Cu16%3E-for-f128" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="convert/trait.FloatToInt.html" title="trait core::convert::FloatToInt">FloatToInt</a>&lt;<a class="primitive" href="primitive.u16.html">u16</a>&gt; for <a class="primitive" href="primitive.f128.html">f128</a></h3></section><section id="impl-FloatToInt%3Cu32%3E-for-f128" class="impl"><a class="src rightside" href="../src/core/convert/num.rs.html#40">Source</a><a href="#impl-FloatToInt%3Cu32%3E-for-f128" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="convert/trait.FloatToInt.html" title="trait core::convert::FloatToInt">FloatToInt</a>&lt;<a class="primitive" href="primitive.u32.html">u32</a>&gt; for <a class="primitive" href="primitive.f128.html">f128</a></h3></section><section id="impl-FloatToInt%3Cu64%3E-for-f128" class="impl"><a class="src rightside" href="../src/core/convert/num.rs.html#40">Source</a><a href="#impl-FloatToInt%3Cu64%3E-for-f128" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="convert/trait.FloatToInt.html" title="trait core::convert::FloatToInt">FloatToInt</a>&lt;<a class="primitive" href="primitive.u64.html">u64</a>&gt; for <a class="primitive" href="primitive.f128.html">f128</a></h3></section><section id="impl-FloatToInt%3Cu8%3E-for-f128" class="impl"><a class="src rightside" href="../src/core/convert/num.rs.html#40">Source</a><a href="#impl-FloatToInt%3Cu8%3E-for-f128" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="convert/trait.FloatToInt.html" title="trait core::convert::FloatToInt">FloatToInt</a>&lt;<a class="primitive" href="primitive.u8.html">u8</a>&gt; for <a class="primitive" href="primitive.f128.html">f128</a></h3></section><section id="impl-FloatToInt%3Cusize%3E-for-f128" class="impl"><a class="src rightside" href="../src/core/convert/num.rs.html#40">Source</a><a href="#impl-FloatToInt%3Cusize%3E-for-f128" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="convert/trait.FloatToInt.html" title="trait core::convert::FloatToInt">FloatToInt</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt; for <a class="primitive" href="primitive.f128.html">f128</a></h3></section></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-f128" class="impl"><a href="#impl-Freeze-for-f128" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="marker/trait.Freeze.html" title="trait core::marker::Freeze">Freeze</a> for <a class="primitive" href="primitive.f128.html">f128</a></h3></section><section id="impl-RefUnwindSafe-for-f128" class="impl"><a href="#impl-RefUnwindSafe-for-f128" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="panic/trait.RefUnwindSafe.html" title="trait core::panic::RefUnwindSafe">RefUnwindSafe</a> for <a class="primitive" href="primitive.f128.html">f128</a></h3></section><section id="impl-Send-for-f128" class="impl"><a href="#impl-Send-for-f128" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="primitive" href="primitive.f128.html">f128</a></h3></section><section id="impl-Sync-for-f128" class="impl"><a href="#impl-Sync-for-f128" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="primitive" href="primitive.f128.html">f128</a></h3></section><section id="impl-Unpin-for-f128" class="impl"><a href="#impl-Unpin-for-f128" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="primitive" href="primitive.f128.html">f128</a></h3></section><section id="impl-UnwindSafe-for-f128" class="impl"><a href="#impl-UnwindSafe-for-f128" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="panic/trait.UnwindSafe.html" title="trait core::panic::UnwindSafe">UnwindSafe</a> for <a class="primitive" href="primitive.f128.html">f128</a></h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="../src/core/any.rs.html#138-142">Source</a><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="any/trait.Any.html" title="trait core::any::Any">Any</a> for T<div class="where">where
    T: 'static + ?<a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="../src/core/any.rs.html#139-141">Source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="../src/core/borrow.rs.html#209-214">Source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="../src/core/borrow.rs.html#211-213">Source</a><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="../src/core/borrow.rs.html#217-221">Source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="../src/core/borrow.rs.html#218-220">Source</a><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-CloneToUninit-for-T" class="impl"><a class="src rightside" href="../src/core/clone.rs.html#273-279">Source</a><a href="#impl-CloneToUninit-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="clone/trait.CloneToUninit.html" title="trait core::clone::CloneToUninit">CloneToUninit</a> for T<div class="where">where
    T: <a class="trait" href="clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone_to_uninit" class="method trait-impl"><a class="src rightside" href="../src/core/clone.rs.html#275-278">Source</a><a href="#method.clone_to_uninit" class="anchor">§</a><h4 class="code-header">unsafe fn <a href="clone/trait.CloneToUninit.html#tymethod.clone_to_uninit" class="fn">clone_to_uninit</a>(&amp;self, dst: <a class="primitive" href="primitive.pointer.html">*mut </a><a class="primitive" href="primitive.u8.html">u8</a>)</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>clone_to_uninit</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/126799">#126799</a>)</span></div></span><div class='docblock'>Performs copy-assignment from <code>self</code> to <code>dst</code>. <a href="clone/trait.CloneToUninit.html#tymethod.clone_to_uninit">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="../src/core/convert/mod.rs.html#765-771">Source</a><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-3" class="method trait-impl"><a class="src rightside" href="../src/core/convert/mod.rs.html#768-770">Source</a><a href="#method.from-3" class="anchor">§</a><h4 class="code-header">fn <a href="convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="../src/core/convert/mod.rs.html#748-761">Source</a><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="../src/core/convert/mod.rs.html#758-760">Source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="../src/core/convert/mod.rs.html#805-815">Source</a><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a class="src rightside" href="../src/core/convert/mod.rs.html#809">Source</a><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="../src/core/convert/mod.rs.html#812-814">Source</a><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="../src/core/convert/mod.rs.html#790-800">Source</a><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a class="src rightside" href="../src/core/convert/mod.rs.html#794">Source</a><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="../src/core/convert/mod.rs.html#797-799">Source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div></section></div></main></body></html>